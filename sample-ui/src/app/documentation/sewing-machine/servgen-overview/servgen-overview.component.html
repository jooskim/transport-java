<h1>ServGen - Overview</h1>

<h3>The Service Adapter Generation Engine.</h3>

<h5>
    ServGen is written in golang. <a href="https://gitlab.eng.vmware.com/autogen/autogen-sources/tree/master/servgen2" target="_blank">Source code is here.</a>
</h5>

<p>
    <strong class="emphasis">ServGen</strong> is the heart of the <strong class="emphasis">Intent Compiler</strong> we call <strong
        class="emphasis">Sewing Machine</strong> and is its most sophisticated component.
    This engine transforms an intent into a Service Adapter that decomposes the intent into a set of requests with responses on the
    bifröst event bus. These Service Adapters completely abstract backend services, and may even orchestrate across multiple backend
    services in order to respond to a request from an application.

</p>

<hr/>

<h3>
    ServGen consumes:
</h3>
<br/>
<ul>
    <li>
        One or more <strong class="emphasis">API Specification</strong> documents through <strong class="emphasis">libswagger</strong>.
    </li>
    <li>
        One or more <strong class="emphasis">Service Adapter Specification</strong> documents.
    </li>
    <li>
        Runtime API bindings generated by <strong class="emphasis">APIGen</strong> in several languages.
    </li>
    <li>
        A collection of bifröst abstractions that all Service Adapters are derived from or use.
    </li>
</ul>

<h3>
    ServGen produces:
</h3>
<br/>
<ul>
    <li>
        A Service Adapter for each <strong class="emphasis">Service Adapter Specification</strong>.
    </li>
    <li>
        A <strong class="emphasis">Service Adapter Interface Specification</strong> document for each Service Adapter.
    </li>
    <li>
        An autogenerated <strong class="emphasis">Mock</strong> Service Adapter for testing.
    </li>
    <li>
        An autogenerated mock ReST service for each Service Adapter invoked from the Mock Service Adapter.
    </li>
    <li>
        Autogenerated and <strong class="emphasis">Custom</strong> Mocks of all data structures that are exported.
    </li>
    <li>
        Autogenerated <strong class="emphasis">Unit Tests</strong> for all autogenerated request handlers and data structures.
    </li>
</ul>

<hr/>


<h2>
    Service Adapters
</h2>

<p>
    A <strong class="emphasis">Service Adapter</strong> is an autogenerated, autonomous module that listens for requests
    on the bifröst event bus and sends responses back to the requestor or broadcasts responses to multiple passive listeners.
    The side effect of some of these responses may include updating global shared state, such as <strong class="emphasis">Stores</strong>
    and trigerring events that can be subscribed to.
</p>
<p>
    For each request processed, the Service Adapter
    may perform API calls to one or more backend services and transform the response(s) in a manner that is consumable
    by the requestor. Some requests do not need subsequent API calls to backend services, and may be satisfied entirely
    by the Service Adapter. Typically, such request handling is done with the addition of <strong class="emphasis">Customized</strong>
    code which fits concisely and seamlessly into the autogenerated code. Moreover, it is also possible to customize any
    autogenerated data structure (classes, maps, etc.), and even publish an enitirely new data structure, complete with
    external interface specification documents.
</p>

<p>
    Service Adapters can be autogenerated in a number of supported languages. At the time of writing this, there are Service
    Adapters for Java and for Typescript in many projects.
</p>

<hr/>

<h2>
    Service Adapter Specification Documents
</h2>

<p>
    All sewing machine components are driven by specifications. Just as the API Specification documents describe how consumers and producers talk to each other,
    The Service Adapter Specification documents describe how to construct a Service Adapter. The specifications describe the layout of the Service Adapter,
    customization of data structures, mock data structures, enumerations, as well as hints for testing. All of these specifications are language-agnostic,
    and the specifications can be used to generate Service Adapters in a multitude of languages.
</p>
<p>
    All Service Adapter Specification documents reside in the folder for the Service Adapter under the sub-folder: <code class="clr-code">specs</code>.
    The name of the Service Adapter's folder must be the same as the name of the Service Adapter. For Typescript, both the name of the Service Adapter
    and that of its folder, must be in <code class="clr-code">kebab-case</code>, while that for Java Service Adapters must be in
    <code class="clr-code">PascalCase</code>. The name of the Service Adapter Specification documents all have the suffix <code class="clr-code">.json</code>.
    By convention, the main spefication document is named <code class="clr-code">service.json</code> for consistency, although ServGen doesn't care as long as the .json suffix exists.
</p>

<p>
    This is an example of the specification for the simplest Service Adapter which handles a single request and provides a response.
    This specifies that a Service adapter with the name <strong class="emphasis">TokenService</strong> is to be created to handle
    a single request: obtain the authentication token for the requestor. This Service Adapter is self-contained and makes no calls to any
    backend services and such requests are termed <code class="clr-code">Custom Requests</code> as they require the addition of customized code to implement the handler for the request.
    This is covered in more detail in subsequent chapters.
</p>
<pre class="code"><code class="language-json" ngNonBindable>
&#123;
    "name": "token",
    "version": "1",
    "service_requests": [
        &#123;
            "service_request": "GetToken",
            "service_response": &#123; "type": "AuthToken" &#125;
        &#125;
   ]
&#125;
</code></pre>
<p>
    This is the minimum specification for a Service Adapter and must have the following properties:
</p>

<h3>
    name
</h3>
<p>
    This property specifies the version of the Service Adapter with a simple integer. It is designed to allow for multiple incompatible
    versions of the Service Adapter to coexist and for requests to be invisibly redirected to the appropriate version of the Service Adapter.
</p>
<h3>
    version
</h3>
<p>
    This property specifies the name of the Service Adapter in the convention of the output language as described above,
    i.e. it must be in <code class="clr-code">kebab-case</code> for Typescript, while that for Java Service Adapters must be in
    <code class="clr-code">PascalCase</code>. In both cases, the final Service Adapter object will be in <code class="clr-code">PascalCase</code>.
    The above specified Service Adapter will be instantiated under the name: <code class="clr-code">TokenService</code>. This is a legacy name from
    when Service Adapters were called Services. In the near future, this Service Adapter will be renamed to: <code class="clr-code">TokenServiceAdapter</code>.
</p>
<h3>
    service_requests
</h3>
<p>
    This property specifies an array of requests that this Service Adapter will handle. In this simple case, it describes a single request with the title <code class="clr-code">GetToken</code>,
    which requires no request parameters, and responds with an object (class) with the type <code class="clr-code">AuthToken</code>. This definition for <code class="clr-code">AuthToken</code>
    is obtained from the API Specification documents. There are additional properties and modifiers that may be added to the Service Adapter Specification documents, and they will be described in
    detail in subsequent chapters.
</p>
<p>
    Beyond this simple example specification, there exists a real Service Adapter in the <code class="clr-code">VMC</code> UI that does make an API call to the <code class="clr-code">VMC</code>
    backend. The Specification for that Service Adapter appears below:
</p>

<pre class="code"><code class="language-json" ngNonBindable>
&#123;
    "name": "token",
    "version": "1",
    "service_requests": [
        &#123;
            "service_request": "GetToken",
            "api": &#123; "uri": "/auth/token", "api_method": "getAuth" &#125;,
            "service_response": &#123; "type": "AuthToken" &#125;
        &#125;
   ]
&#125;
</code></pre>
<p>
    The addition of <code class="language-json" ngNonBindable>"api": &#123; "uri": "/auth/token", "api_method": "getAuth" &#125;</code> above,
    transforms the Service Adapter into one that calls the API of a backend service to do the work of obtaining the <code class="clr-code">AuthToken</code>.
    The <code class="clr-code">api</code> property refers to an object that describes the required API call to satisfy the service request. This object contains
    additional properties.
</p>

<h3>
    api
</h3>
<p>
    A <code class="clr-code">service_request</code> descriptor may only contain a single <code class="clr-code">api</code> property. When a request can only
    be satisfied by multiple API calls, perhaps even to different backend services, then there is a <code class="clr-code">service_request</code> described
    for each of the API calls, with a final <code class="clr-code">Custom Request</code> that ties them all together into a single response.
</p>

<h3>
    uri
</h3>
<p>
    The <code class="clr-code">uri</code> specifies the endpoint for an API call and its format depends on the type of transport that is used to communicate with the
    backend service. When a ReST service is used as the transport, this specifies the URI of the ReST endpoint. Other formats may be used for future transports that
    replace ReST. APIGen produces binding code for all backend APIs, and these can be consulted for determining the necessary endpoints.
</p>


<h3>
    api_method
</h3>
<p>
    APIGen creates classes for each API endpoint described in the API Specification documents. Each such API class has one or more methods to perform API calls to backend services.
    <code class="clr-code">api_method</code> specifies which specific method within that API class is to be invoked. For backend services that use the ReST service as transport,
    these methods are GET, POST, PUT, PATCH, and DELETE. APIGen converts them into more readable names, by default, httpGet, httpPost, ..., etc. The use of extensions in the API
    Specification documents can make these names even more readable. The method name <code class="clr-code">getAuth</code> is an example of an autogenerated readable method
    name from the use of these extensions. The earlier documentation of <code class="clr-code">libswagger</code> describes these extensions in more detail.
</p>

<p>
    These and other properties in <code class="clr-code">service.json</code> as well as those for the entirety of possible Service Adapter specifications are described in subsequent chapters
    in great detail as this overview is intended to be just that.

</p>

<hr/>


<h2>
    Service Adapter Autogeneration
</h2>
<p>
    Just the Service Adapter specification for the <code class="clr-code">Token</code> Service Adapter above along with the API Specification documents from the backend services, are sufficient for
    ServGen to autogenerate the complete <code class="clr-code">TokenService</code> Adapter without writing a single line of code! This includes the code for the Service Adapter, a mock for the
    Service Adapter, a mock for a ReST service that mocks all the API calls that <code class="clr-code">TokenService</code> makes, mocks of all data structures, 'specially
    <code class="clr-code">AuthToken</code>, all unit tests, and very importantly, an OpenApi document that describes how to communicate with <code class="clr-code">TokenService</code>
    using the bifröst event bus.
</p>
<p>
    Before the autogeneration of the Service Adapter for <code class="clr-code">Token</code>, there exists a folder for the Service Adapter called <code class="clr-code">token</code>,
    which has a singrle sub-folder called <code class="clr-code">specs</code>, which has a single Service Adapter Specification file called <code class="clr-code">service.json</code>.
    Let's take a cursory look at what happens when we run ServGen on this Service Adapter Specification document with the output language set to <code class="clr-code">Typescript</code>.
</p>
<p>
    The first step that ServGen takes is to create two new sub-folders called <code class="clr-code">auto</code> and <code class="clr-code">tests</code>. The contents of these folders are
    <code class="clr-code">readonly</code> and are destroyed and re-created each time that ServGen runs, and should, therefore, never be directly modified, as any changes will
    be lost in the autogeneration process. In fact, only the <code class="clr-code">customizable files</code> (described later) in the top level folder for the
    Service Adapter, are modifiable and not overwritten, unless the <code class="clr-code">--force</code> option is provided to ServGen.
</p>
<h3>
    auto
</h3>
<p>
    The <code class="clr-code">auto</code> folder contains code for the core <code class="clr-code">TokenService</code> Adapter, all models used or exported by
    the TokenService Adapter, and code that implements all the interfaces
    to the service adapter, including the data structures used to communicate with it over the bifröst event bus.
</p>

<h3>
    tests
</h3>
<p>
    The <code class="clr-code">tests</code> folder contains code for all the unit tests for the <code class="clr-code">TokenService</code> Adapter, mocks for all data structures,
    including those used for communicating via the bifröst event bus, the mock TokenService Adapter, and a mock ReST service for the API calls used
    by the TokenService Adapter.
</p>
<hr/>
<p>
    Let's take a brief look at some of these autogenerated files:
</p>

<h3>
    Models
</h3>
<p>
    The <code class="clr-code">TokenService</code> Adapter exports a single object: <code class="clr-code">Authtoken</code> as returned from the backend <code class="clr-code">VMC</code>
    service. This object is described in VMC API Specification document. APIGen has already processed this file and produced a typescript class from it:
</p>
<pre class="code"><code class="language-typescript" ngNonBindable>
export class BaseAuthToken &#123;
    public id_token:    string; // Openid Token
    public auth_token:  string; // Current Auth Token

    constructor (json?: any) &#123;
        if (json) &#123;
            this.auth_token = json['auth_token'];
            this.id_token = json['id_token'];
        &#125;
    &#125;
&#125;
</code></pre>
<p>
    Please note that APIGen has prepended <code class="clr-code">Base</code> to <code class="clr-code">AuthToken</code> which allows us to derive a child class called
    <code class="clr-code">AuthToken</code> which derives from it. ServGen uses OOP inheritance to extend this base class and customize it as necessary, and does so by
    autogenerating it in the <code class="clr-code">auto</code> sub-folder in a file called <code class="clr-code">AuthToken.ts</code> with the following content:
</p>
<pre class="code"><code class="language-typescript" ngNonBindable>
import &#123; BaseAuthToken &#125; from '@vmc/api/vmc-api';


export class AuthToken extends BaseAuthToken &#123;
    private constructor (baseAuthToken: BaseAuthToken) &#123;
        super(baseAuthToken);
    &#125;

    public static factory(baseAuthToken?: BaseAuthToken): AuthToken &#123;
        return new AuthToken(baseAuthToken as BaseAuthToken);
    &#125;

    public get isValid(): boolean &#123;
        // AuthToken has no required properties.
        return (
            true
        );
    &#125;
&#125;
</code></pre>
<p>
    The <strong class="emphasis">factory</strong> method converts a <code class="clr-code">BaseAuthToken</code> class into the <code class="clr-code">AuthToken</code> class,
    and thenceforth, we only use the latter, as the base class generated by APIGen is inaccessible outside the services layer.
</p>
<h3>
    AutoService
</h3>
<p>
    Servgen autogenerates the TokenService adapter in the <code class="clr-code">auto</code> sub-folder with the name <code class="clr-code">AutoTokenService.ts</code>, a name whose
    intent will become clear when <code class="clr-code">customized Service Adapters</code> are described in detail later. This is the content of that file with imports removed:
</p>
<pre class="code"><code class="language-typescript" ngNonBindable>
export class AutoTokenService extends AbstractAutoService&lt;TokenRequestObject, TokenResponseObject&gt; &#123;
    public lastApi: any; // Unit test support
    protected version = '1';

    protected constructor() &#123;
        super('TokenService', TokenChannel.request);
    &#125;

    protected handleServiceRequest(tokenRequestObject: TokenRequestObject, args?: MessageArgs) &#123;
        switch (tokenRequestObject.request) &#123;
            case TokenServiceRequest.GetToken: &#123;
                const apiObject = this.genApiObject(tokenRequestObject,
                                  new TokenGetTokenResponseObject());

                const successHandler = 
                    (context: ApiObject&lt;TokenRequestObject, TokenResponseObject&gt;, apiResponse: AuthToken, messageArgs: MessageArgs) =&gt; &#123;
                        const serviceResponse = AuthToken.factory(apiResponse);
                        this.apiSuccessIntercept(context, serviceResponse, messageArgs);
                    &#125;;

                const failureHandler =
                    (context: ApiObject&lt;TokenRequestObject, TokenResponseObject&gt;,
                     err: RestError, messageArgs: MessageArgs) =&gt; &#123;
                        this.apiFailureIntercept(context, err, messageArgs);
                    &#125;;

                (this.lastApi = new API_AuthToken(this.apiBridge, apiObject, args))
                .getAuth(// Get
                    successHandler,
                    failureHandler
                );
                break;
            &#125;

            case TokenServiceRequest.GetServiceVersion: &#123;
                const apiObject = this.genApiObject(tokenRequestObject,
                                  new TokenGetServiceVersionResponseObject(
                                    new ServiceVersion(this.serviceName, this.version)
                                  )
                );

                this.apiSuccessHandler(apiObject, new ServiceVersion(this.serviceName, this.version), args);
                break;
            &#125;

            default:
                this.postError(tokenRequestObject.channel as string, this.serviceRequestError, args);
        &#125;
    &#125;

    protected apiSuccessIntercept(apiObject: ApiObject&lt;TokenRequestObject, TokenResponseObject&gt;,
                                  payload: any,
                                  args?: MessageArgs) &#123;
        this.apiSuccessHandler(apiObject, payload, args);
    &#125;

    protected apiFailureIntercept(apiObject: ApiObject&lt;TokenRequestObject, TokenResponseObject&gt;,
                                  err: RestError, args?: MessageArgs) &#123;
        this.apiFailureHandler(apiObject, err, args);
    &#125;
&#125;</code></pre>
<p>
    Note that in addition to generating code to handle the specified <code class="clr-code">GetToken</code>, request,
    Servgen has automatically inserted a <code class="clr-code">GetServiceVersion</code> into the request handler,
    as it does for all Service Adapters so that all of them can respond to a request to determine the version
    of the Service Adapter.
</p>

<p>
    There are a number of other files that are autogenerated that won't be described in detail in this overview,
    but will be extensively covered in subsequent chapters.
</p>

<hr/>

<h2>
    Containers, Nested Containers, and Types
</h2>
<p>
    Since the <strong class="emphasis">Intent Compiler</strong> is language-agnostic, it has an abstract definition of
    what constitutes the <code class="clr-code">type</code> of any entity. Internally <code class="clr-code">libswagger</code>
    maintains the following data structure (truncated) for all objects: parameters, properties, responses, mocks, etc.:
</p>

<pre class="code"><code class="language-go" ngNonBindable>
type CommonType struct &#123;
	Container   string              // The outermost container: "array" or "map"
	Nested      string              // The nested container: "array" or "map"
	Type        string              // The content: a class, or a basic type, e.g. "string"
    :
    :
&#125;
</code></pre>
<p>
    The <strong class="emphasis">Intent Compiler</strong> only permits a single level of container nesting as described in the
    documentation for <code class="clr-code">libswagger</code>. So, the deepest level that can be expressed for a data
    structure would be the following example (in both Typescript and in Java):

    <code class="clr-code">Map&lt;string, Array&lt;AuthToken>></code> - which defines an entity consisting of a map that
    contains an array of <code class="clr-code">AuthToken</code> classes. No further depth can be expressed in the <strong class="emphasis">Intent Compiler</strong>
    and it is considered bad practice to use such complex data structures in API definitions. It is, however, perfectly acceptable to have
    such complex structures for implementing backend services and ther is noi requirement for data structures used in APIs to be identical
    to those used for implementing a backend service.
</p>
<p>
    In order to declare an entity to have the above type in Service Adapter Specification documents, the following would suffice:
    <br/>
    <code class="language-json" ngNonBindable> &#123; "container": "map", "nested": "array", "type": "AuthToken" &#125;</code>
    <br/>
    That is all you need to know about specifying a type for any entity in a Service Adapter Specification document.
</p>

<hr/>
