<appfab-typescript-badges></appfab-typescript-badges>
<h1>Using Transactions.</h1>
<p>
    A technique that can be used to encapsulate a conversation between a component and a service, or between
    services themselves - is to use a transaction.
</p>
<p>
    Transactions via the Bifr√∂st are not traditional transactions, in the sense that they can be rolled back if they fail, instead they are defined as a
    group of requests and responses that have to occur before the transaction can be considered complete.
</p>
<p>
    For example, if you need to call a number of services to get a number of responses, in order to be able to construct
    a response for a component - this would be a transactions.

</p>
<p>
    Similarly if you need to make a number of calls to services and wait for stores to be available and populated, this would also be a
    transaction. Transactions can be either synchronous, or asynchronous.
</p>
<p>
    Transactions are asynchronous by default. Essentially when you commit transactions, all the requests will be fired
    at once, the transaction will complete once responses to all those requests have been
    completed. These responses can arrive in any order and at any time (hence the asynchronous nature).
</p>
<p>
    However there may be times when you want your logic to run in a synchronous manner
    (due to your API design for example). When running a synchronous transaction, each request in the transaction will
    only fire once the previous one has completed. This is obviously a lot slower,
    but may be required based on your needs.
</p>


<p>
    Below is an example of a Java Consumer that calls <code class="clr-code">PongService</code> and <code class="clr-code">CalendarService</code> via an
    asynchronous transaction
</p>

<h3>Java PongCalendarServiceConsumer</h3>
<pre class="code"><code class="language-typescript" ngNonBindable>package samples.pong;

import com.vmware.bifrost.bridge.Request;
import com.vmware.bifrost.bridge.Response;
import com.vmware.bifrost.bus.Transaction;
import com.vmware.bifrost.bus.model.Message;
import com.vmware.bifrost.core.AbstractBase;
import com.vmware.bifrost.core.util.ClassMapper;
import org.springframework.stereotype.Component;
import samples.calendar.CalendarService;

import java.util.UUID;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;

@Component
public class PongCalendarServiceConsumer extends AbstractBase &#123;

    private ScheduledExecutorService executorService;

    PongCalendarServiceConsumer() &#123; this.executorService = Executors.newScheduledThreadPool(5); &#125;

    /**
     * Call PongService and Calendar Service as a part of a transaction
     */
    @Override
    public void initialize() &#123;
        // create task, wait 1 second before executing.
        Runnable runTransactionTask = () -&gt; this.runTransaction();
        executorService.schedule(runTransactionTask, 1000,  TimeUnit.MILLISECONDS);
    &#125;

    private void runTransaction() &#123;
        // create async transaction
        UUID transactionId = UUID.randomUUID();
        Transaction transaction = bus.createTransaction(Transaction.TransactionType.ASYNC, transactionId);

        // send request to PongService
        transaction.sendRequest(
                PongService.Channel,
                new Request&lt;String&gt;(transactionId, "Basic") // request basic pong
        );

        // send request to CalendarService
        transaction.sendRequest(
                CalendarService.Channel,
                new Request&lt;String&gt;(transactionId, "time") // request time
        );

        // when transaction is done
        transaction.onComplete(
                (Message[] responses) -&gt; &#123;

                    // concatenate service responses into a string.
                    StringBuilder serviceResponses = new StringBuilder();
                    for(Message msg: responses) &#123;

                        String serviceResponse = ClassMapper.CastPayload(String.class, (Response)msg.getPayload());
                        serviceResponses.append("&gt; " + serviceResponse + " "); // add each response together.
                    &#125;

                    // log output.
                    this.logInfoMessage("PongCalendarServiceConsumer:", "Response", serviceResponses.toString());
                &#125;
        );

        // commit transaction.
        transaction.commit();
    &#125;
&#125;</code></pre>

<hr>

