/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.vmware.bifrost;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.vmware.bifrost.broker.GalacticMessageHandler;
import com.vmware.bifrost.broker.nats.NatsBrokerConnector;
import com.vmware.bifrost.broker.nats.NatsChannelConfig;
import com.vmware.bifrost.broker.nats.NatsSubscription;
import io.nats.client.Connection;
import io.nats.client.Dispatcher;
import io.nats.client.Message;
import io.nats.client.MessageHandler;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.mockito.Mockito;
import org.mockito.stubbing.Answer;

import java.time.Duration;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

public class NatsBrokerConnectorTest {

    private Connection natsConnection;

    @Before
    public void setUp() {
        this.natsConnection = Mockito.spy(Connection.class);
    }

    @Test
    public void testCreate() {
        NatsBrokerConnector brokerConnector = new NatsBrokerConnector(natsConnection);
        Assert.assertNotNull(brokerConnector);
        Assert.assertNotNull(brokerConnector.getMessageBrokerId());
    }

    @Test
    public void testDisconnect() {
        NatsBrokerConnector brokerConnector = new NatsBrokerConnector(natsConnection);
        CompletableFuture<Boolean> completableFuture = Mockito.spy(CompletableFuture.class);
        completableFuture.complete(true);

        try {
            Mockito.when(completableFuture.get()).thenReturn(true);
            Mockito.when(natsConnection.drain(Mockito.any(Duration.class))).thenReturn(completableFuture);
            brokerConnector.disconnectMessageBroker();
        } catch (Exception e) {
            Assert.fail("Should not fail during disconnection");
        }
    }

    @Test
    public void testSubscription_emptySubject() {
        NatsBrokerConnector brokerConnector = new NatsBrokerConnector(natsConnection);
        GalacticMessageHandler messageHandler = Mockito.spy(GalacticMessageHandler.class);

        NatsSubscription subscription = brokerConnector
                .subscribeToChannel(brokerConnector.newDuplexGalacticChannel(""), messageHandler);
        Assert.assertNull(subscription);
    }

    @Test
    public void testSubscription_duplexChannel() {
        NatsBrokerConnector brokerConnector = new NatsBrokerConnector(natsConnection);

        // manually invoke the MessageHandler object passed as an argument to createDispatcher
        Mockito.when(natsConnection.createDispatcher(Mockito.any(MessageHandler.class))).then((Answer<Dispatcher>) invocation -> {
            MessageHandler handler = invocation.getArgument(0, MessageHandler.class);
            Message msg = Mockito.spy(Message.class);
            Mockito.when(msg.getData()).thenReturn(new byte[]{'t', 'e', 's', 't'});
            handler.onMessage(msg);
            return Mockito.spy(Dispatcher.class);
        });

        GalacticMessageHandler messageHandler = Mockito.spy(GalacticMessageHandler.class);
        Mockito.doAnswer((Answer<Object>) invocation -> {
            String object = invocation.getArgument(0, String.class);
            Assert.assertEquals("test", object);
            return null;
        }).when(messageHandler).onMessage(Mockito.any(Object.class));

        NatsSubscription subscription = brokerConnector
                .subscribeToChannel(brokerConnector.newDuplexGalacticChannel("chan"), messageHandler);
        Assert.assertNotNull(subscription);
    }

    @Test
    public void testSubscription_publishOnlyChannel() {
        NatsBrokerConnector brokerConnector = new NatsBrokerConnector(natsConnection);

        // manually invoke the MessageHandler object passed as an argument to createDispatcher
        Mockito.when(natsConnection.createDispatcher(Mockito.any(MessageHandler.class))).then((Answer<Dispatcher>) invocation -> {
            MessageHandler handler = invocation.getArgument(0, MessageHandler.class);
            Message msg = Mockito.spy(Message.class);
            Mockito.when(msg.getData()).thenReturn(new byte[]{'t', 'e', 's', 't'});
            handler.onMessage(msg);
            return Mockito.spy(Dispatcher.class);
        });

        GalacticMessageHandler messageHandler = Mockito.spy(GalacticMessageHandler.class);
        Mockito.doAnswer((Answer<Object>) invocation -> {
            String object = invocation.getArgument(0, String.class);
            Assert.assertEquals("test", object);
            return null;
        }).when(messageHandler).onMessage(Mockito.any(Object.class));

        NatsSubscription subscription = brokerConnector
                .subscribeToChannel(brokerConnector.newPublishOnlyGalacticChannel("chan"), messageHandler);
        Assert.assertNotNull(subscription);
        Mockito.verifyZeroInteractions(messageHandler);

    }

    @Test
    public void testUnsubscription() {
        GalacticMessageHandler messageHandler = Mockito.spy(GalacticMessageHandler.class);
        NatsBrokerConnector brokerConnector = new NatsBrokerConnector(natsConnection);
        Mockito.when(natsConnection.createDispatcher(Mockito.any(MessageHandler.class))).then((Answer<Dispatcher>) invocation -> {
            MessageHandler handler = invocation.getArgument(0, MessageHandler.class);
            Message msg = Mockito.spy(Message.class);
            Mockito.when(msg.getData()).thenReturn(new byte[]{'t', 'e', 's', 't'});
            handler.onMessage(msg);
            return Mockito.spy(Dispatcher.class);
        });

        NatsSubscription subscription = brokerConnector
                .subscribeToChannel(brokerConnector.newDuplexGalacticChannel("chan"), messageHandler);

        // NatsSubscription is package-private and thus will not be available in test package. there is no way other than
        // using Whitebox to test a positive scenario
        Assert.assertFalse(brokerConnector.unsubscribeFromChannel(subscription));
    }

    @Test
    public void testSendMessage_emptySubject() {
        NatsBrokerConnector brokerConnector = new NatsBrokerConnector(natsConnection);
        Assert.assertFalse(brokerConnector.sendMessage(brokerConnector.newDuplexGalacticChannel(""), "test"));
    }

    @Test
    public void testSendMessage_validResult() {
        ObjectMapper mapper = new ObjectMapper();
        Map<String, String> map = new LinkedHashMap();
        map.put("payload", "test");

        NatsBrokerConnector brokerConnector = new NatsBrokerConnector(natsConnection);
        Mockito.doAnswer((Answer<?>) invocation -> {
            Assert.assertEquals("chan", invocation.getArgument(0, String.class));
            Assert.assertEquals(mapper.writer().writeValueAsString(map), new String(invocation.getArgument(1, byte[].class)));
            return null;
        }).when(natsConnection).publish(Mockito.anyString(), Mockito.any(byte[].class));

        boolean results = brokerConnector.sendMessage(
                brokerConnector.newDuplexGalacticChannel("chan"), map);
        Assert.assertTrue(results);
    }

    @Test
    public void testSubscription_listenOnlyChannel() {
        NatsBrokerConnector brokerConnector = new NatsBrokerConnector(natsConnection);
        Mockito.doAnswer((Answer<?>) invocation -> {
            Assert.fail("Should not have been called");
            return null;
        }).when(natsConnection).publish(Mockito.anyString(), Mockito.any(byte[].class));

        boolean results = brokerConnector.sendMessage(
                brokerConnector.newListenOnlyGalacticChannel("chan"), "should-not-be-sent");
        Assert.assertTrue(results);
        Mockito.verifyZeroInteractions(natsConnection);
    }
}
