<appfab-typescript-badges></appfab-typescript-badges>
<h1>
    Connecting to multiple brokers
</h1>

<h3>One UI, multiple brokers</h3>
<p>
    Sometimes you want to connect to more than one fabric endpoint in your UI, and we have seen a few teams requesting
    that Bifröst have the capability to do so. Starting with <strong>Bifröst TS 0.15.0</strong>, you can easily achieve that by using
    the same method as when you would connect to a single fabric instance. As long as the brokers
    follow the STOMP v1.2 specifications and are provided through either Bifröst or any other means, you can communicate with
    galactic channels across multiple brokers. See below the detailed step-by-step guide to learn how to leverage this feature
    and what to look out for.
</p>
<hr/>
<h3>Step 1: Connect to multiple brokers</h3>
<p>
    Connecting to multiple fabric instances is no different from connecting to a single instance. You create connection
    and disconnection handlers per broker and establish connection using <code>fabric.connect()</code>.
</p>
<pre class="code"><code class="language-typescript" ngNonBindable>// first endpoint
this.fabric.connect(
    () => &#123;&#125;,
    () => &#123;&#125;,
    'appfabric.vmware.com'
);

// second endpoint
this.fabric.connect(
    () => &#123;&#125;,
    () => &#123;&#125;,
    'somehost',
    12345,
    '/custom-fabric-endpoint'
);
</code></pre>
<p>
    Next, you may want to set up listeners for connection events for the brokers using <code>fabric.whenConnectionStateChanges()</code>.
    There is an important change introduced in Bifröst 0.15.0 you should be aware of.
</p>
<h4>Change to <code>fabric.whenConnectionStateChanges() function signature</code></h4>
<br/>
<clr-alert [clrAlertClosable]="false" [clrAlertType]="'warning'">
    <clr-alert-item>
        <span class="alert-text">
            IMPORTANT: This is a breaking change for 0.14.x and any prior versions
        </span>
    </clr-alert-item>
</clr-alert>
<p>
    <code>fabric.whenConnectionStateChanges()</code> now accepts a mandatory argument that specifies the broker
    endpoint. It is composed with host, port and endpoint for the fabric and can be easily formulated by using a
    utility function <code>BusUtil.getFabricConnectionString()</code>. An example looks as follows:
</p>
<pre class="code"><code class="language-typescript" ngNonBindable>this.bus.fabric.whenConnectionStateChanges(
    BusUtil.getFabricConnectionString('appfabric.vmware.com', 80, '/fabric'))
        .subscribe((state: FabricConnectionState) => &#123; ... &#125; );
</code></pre>

<h3>Step 2: Create galactic channels across multiple fabric endpoints</h3>
<p>
    Just like you would in the previous chapter, <a routerLink="/documentation/bifrost/ts/connecting-to-fabric">
    Connecting to the Fabric</a>, you use the same <code>bus.markChannelAsGalactic()</code> for creating a galactic
    channel and <code>bus.markChannelAsLocal()</code> for converting it back to a local channel. A major difference and
    caveat to keep in mind though is that when you have more than one broker session connected, you will need to
    specify the target broker endpoint, as a second parameter, that you wish to associate the channel with:
</p>

<pre class="code"><code class="language-typescript" ngNonBindable>// mark channel-A as galactic on the first broker
this.bus.markChannelAsGalactic('channel-A',
    BusUtil.getFabricConnectionString('appfabric.vmware.com', 80, '/fabric'));

// mark channel-B as galactic on the second broker
this.bus.markChannelAsGalactic('channel-B',
    BusUtil.getFabricConnectionString('somehost', 12345, '/custom-fabric-endpoint'));
</code></pre>
<p>
    If you don't specify the second parameter, Bifröst will not be able to tell which channel should be mapped to which broker
    and eventually throws an error in the console asking you to explicitly provide it. <strong>If there is only one
    broker to connect to, you don't need to provide the second parameter</strong>, as Bifröst will automatically fill it out for you.
</p>
<p>
    And that is how to talk to galactic channels mapped across different brokers!
</p>

<hr/>
<h3>Extra: Multiple galactic channels across distributed brokers with the same channel name</h3>
<p>
    In the example above, we mapped two channels of differing names to their respective broker. It naturally makes sense
    that you will invoke different channels for different operations. However, you can assign the same channel name to the both mappings
    if you meet the following conditions:
</p>
<br/>
<ol>
    <li>
        All of your distributed brokers communicate over WebSocket with STOMP
    </li>
    <li>
        The channel deals with the same type of request and response data no matter what broker instance
    </li>
</ol>
