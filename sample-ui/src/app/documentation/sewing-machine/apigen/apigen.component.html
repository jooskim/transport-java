
<h1>APIGen - CLI</h1>

<h3>The Translation Engine for API Specifications.</h3>

<p>
    In the suite of components that make up the <strong class="emphasis">Intent Compiler</strong> we call <strong
    class="emphasis">Sewing Machine</strong>, the role of <strong class="emphasis">APIGen</strong> is to translate
    supported
    specification documents into Application Fabric specific bindings in a number of supported programming languages to
    be
    manifest as models and operations. This component is also the 2nd stage of the compiler’s pipeline.
</p>

<hr/>

<h2>
    Specifications and Languages
</h2>

<p>
    APIGen is agnostic to the type of specification documents it indirectly consumes, and depends on <strong
    class="emphasis">libswagger</strong> for
    parsing them and transforming them into a set of abstractions that it can build on. This allows new types of
    specification documents to be added, or the existing ones modified, or document parsing libraries changed, without
    affecting APIGen.
</p>
<p>
    At the time of writing this, <strong class="emphasis">libswagger</strong> understands <strong
    class="emphasis">Swagger 2.0</strong> and <strong class="emphasis">OpenAPI 3.0</strong> documents. The
    inclusion of Protocol Buffers as used by gRPC is envisioned in the roadmap.
</p>

<p>
    At its core, APIGen converts an abstraction of specifications as produced by <strong
    class="emphasis">libswagger</strong>, into yet another
    <strong class="emphasis">language-neutral</strong> set of abstractions that can then be consumed by
    language-specific plugins to create libraries that
    can be used by applications written in those languages. At the time of writing this, APIGen contains plugins for
    <strong class="emphasis">Typescript</strong>, <strong class="emphasis">Java</strong>, and a prototypical plugin for
    <strong class="emphasis">Go</strong>. A plugin for <strong class="emphasis">C++</strong> is envisioned in the
    roadmap.
</p>

<hr/>

<h2>
    Using APIGen
</h2>

<p>
    The following is a detailed description of how to invoke APIGen (obsolete and deprecated options have been
    excluded):
</p>

<pre class="code"><code class="language-json" ngNonBindable>Usage: apigen &lt;options&gt; &lt;YAML prefix&gt;

 -b, --root=$&#123;HOME&#125;/xxx                         Project Root path
 -c, --compatibility                            Compatibility Mode
 -d, --debug                                    Debug Output
 -e, --extern="vmc"                             Extern YAML
 -F, --force                                    Force overwrite
 -h, --help                                     Display Help
 -H, --host=localhost                           Override host specification in YAML API methods
 -j, --no-javadocs                              Suppress generatation of javadocs for API methods
 -l, --language=&lt;typescript | java | c++ | go&gt;  Codegen Language
 -m, --models-only                              Models only (no API classes)
 -n, --namespace=Base                           Namespace prefix hasRequiredProperties() function (typescript)
 -O, --optional-flag                            In typescript, flag optional properties in models
 -o, --output=./java | xxx-api.ts               Apigen Output Folder or filename when --singel-file specified
 -p, --apiDir=&lt;YAML folder&gt;                     YAML folder  (relative to project root)
 -P, --package=com.vmware.api.vmc               Package (for java)
 -R, --rename-yaml=ngw:NGW                      Prepend all objects in specified YAML with prefix
 -S, --single-file                              Single file output
 -s, --suffix="-api-doc.yaml"                   Suffix to convert YAML file names to api.[ts | java | cpp | go]
 -t, --trace                                    Trace Output
 -u, --full-uri                                 Generate full URI from 'host' and 'scheme'
 -v, --verbose                                  Verbose Output
 -V, --version                                  Show Version
 -w, --no-warnings                              Turn off warnings
 -x, --no-null-object                           Don't create an empty object for a
                                                property if the property is passed as
                                                null to the constructor</code></pre>

<table class="table table-noborder flag-table">
    <thead>
    <tr>
        <th class="left flag-header">Flag</th>
        <th>Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td class="left flag">-b&lt;path&gt; | --root=&lt;path&gt;</td>
        <td class="flag-value">This option declares the absolute path to the root of the Project directory. All
            subsequent location
            specifications are relative to this root path. If this option is skipped, APIGen defaults to <strong
                class="emphasis">$&#123;HOME&#125;/ui</strong> for
            historical reasons. Path specifications may include the ~ character which will be replaced by the <strong
                class="emphasis">HOME</strong>
            folder of the invoking user, or <strong class="emphasis">~&lt;user&gt;</strong>, which will be replaced by
            the <strong class="emphasis">HOME</strong> folder of the specified
            <strong class="emphasis">&lt;user&gt;.</strong>
        </td>

    </tr>
    <tr>
        <td class="left flag">-d | --debug</td>
        <td class="flag-value">
            Used by APIGen developers to emit debug output.
        </td>
    </tr>
    <tr>
        <td class="left flag">-e &lt;YAML prefix&gt; | --extern=&lt;YAML prefix&gt;</td>
        <td class="flag-value">
            Many of the YAML specifications prevalent at VMware use partial object definitions with the intent that a
            more authoritative definition is to be obtained from another YAML. Examples of this behavior include the
            definition of the <strong class="emphasis">Task</strong> class and <strong class="emphasis">Sddc</strong>
            class, that are both authoritatively defined in <strong class="emphasis">vmc-api-doc.yaml</strong>, but
            has partial definitions in other YAML files (e.g. <strong class="emphasis">vmc-draas-api-doc.yaml</strong>).
            When this option is specified.
            <br/><br/>
            APIGen does not emit any definition for object names that are duplicated in the authoritative YAML (in this
            case vmc, without the suffix) and instead, issues import declarations (in the respective output language)
            for those duplicated objects from their definition in the authoritative YAML.
        </td>
    </tr>
    <tr>
        <td class="left flag">-F | --force</td>
        <td class="flag-value">
            This option is ignored by APIGen and is only provided for consistency with all the other components in the
            Intent Compiler. Usually, this flag is provided to an Intent Compiler component (e.g. <strong
            class="emphasis">ServGen</strong>, or <strong class="emphasis">SpecGen</strong>)
            to permit them to overwrite a file that is otherwise customizable (and therefore, not normally overwritten),
            however, since none of the output files from APIGen are customizable, they are overwritten irrespective of
            the presence of this flag.
        </td>
    </tr>
    <tr>
        <td class="left flag">-h | --help</td>
        <td class="flag-value">
            Displays all the options recognized by APIGen.
        </td>
    </tr>
    <tr>
        <td class="left flag">-H localhost | --host=localhost</td>
        <td class="flag-value">
            This option is used to override the host specification in the API specification document with an alternate
            one, typically during development. An alternate (preferred) strategy is to use a proxy configuration file.
            This option also requires the code class="clr-code">–single-file&lt;/code&gt;--full-uri option to obtain the desired result.
        </td>
    </tr>
    <tr>
        <td class="left flag">-l &lt;typescript | java | go&gt; | --language=&lt;typescript | java | go&gt;</td>
        <td class="flag-value">
            This option is used to specify the language plugin to be used for the output from APIGen. Currently, the
            valid plugins are: <strong class="emphasis">typescript</strong>, <strong class="emphasis">java</strong>, and
            <strong class="emphasis">go</strong>.
        </td>
    </tr>

    <tr>
        <td class="left flag">-m | --models-only</td>
        <td class="flag-value">
            Normally, APIGen generates code for Classes/Enums as well as API Classes/Methods. Specifying this option
            suppresses the generation of API Classes/Methods and only generates Classes/Enums (definitions). This is
            useful when testing a new language plugin before all the pieces have been implemented.
        </td>
    </tr>

    <tr>
        <td class="left flag">-n | --namespace=&lt;prefix&gt;</td>
        <td class="flag-value">
            This option prepends a prefix to every class definition output by APIGen. If this option is not provided,
            APIGen defaults to using Base as that prefix. The purpose of this is to rename the class names sent by a
            responder and preserve that intact, while deriving a new class from this base class by the application, and
            delineates the boundary of immutability of the original class.
            <br/><br/>
            References to this base class may only be
            permitted from Service Adapters, and never from the application itself. The application may, however, access
            the derived class[es] provided by <strong class="emphasis">ServGen</strong>, which automatically generates
            the children of this parent base
            class, while the base class output of APIGen is only accessible from within the Service Adapter and may be
            in a language that is different from that of the application
        </td>
    </tr>

    <tr>
        <td class="left flag">-N | --no-hasRequiredProperty</td>
        <td class="flag-value">
            For historical reasons (swagger2ts), every class emitted by APIGen has a method called
            <code class="clr-code">hasRequiredProperties()</code> which checks that a fully populated class has all the
            properties that are marked as
            required. There are a number of legacy components in VMC that invoke this method procedurally from
            application space – something that will not be possible once the Service Adapter Layer is detached from the
            application. Once VMC has been refactored to remove such references, this option will be turned on by
            default.
        </td>
    </tr>

    <tr>
        <td class="left flag">-O | --optional-flag</td>
        <td class="flag-value">
            Normally, APIGen does not respect whether a property is optionally present in a class, and defines all
            properties from the YAML. This can have an undesirable side effect for consumers that check for the presence
            of these optional properties and make decisions based on their absence. Specifying this option removes these
            optional properties if no data is provided for them in the response to an API request.
        </td>
    </tr>

    <tr>
        <td class="left flag">-o &lt;output filename or folder&gt; | --output=&lt;output filename or folder&gt;</td>
        <td class="flag-value">
            When the <code class="clr-code">–single-file</code> option is provided to APIGen then the <code
            class="clr-code">–output</code> is used to
            provide the filename where the output will reside. Alternatively, if <code
            class="clr-code">–single-file</code> is not specified, then
            –output specifies the full path of a folder where class files will be created. If the folder doesn’t exist,
            it will be created. See the
            example invocations below.
        </td>
    </tr>

    <tr>
        <td class="left flag">-p &lt;relative path&gt; | --apiDir=&lt;relative path&gt;</td>
        <td class="flag-value">
            This option is mandatory and specifies the path of the <strong class="emphasis">api</strong> folder, <strong
            class="emphasis">relative</strong> to the project root specified
            using <code class="clr-code">–root</code> above. The <strong class="emphasis">api</strong> folder is the
            location where both YAML files and default output files (e.g.
            *-api.ts) reside.
        </td>
    </tr>

    <tr>
        <td class="left flag">-P &lt;package name&gt; | --package=&lt;package name&gt;</td>
        <td class="flag-value">
            For languages that use packages, e.g. Java, Go, etc., this specifies the package name to insert in the
            output file(s) as it is not always possible to infer the package name from the output folder’s path.
        </td>
    </tr>

    <tr>
        <td class="left flag">-R &lt;YAML : class prefix&gt; --rename-yaml=&lt;YAML : class prefix&gt;</td>
        <td class="flag-value">
            Since there is no central repository for YAML files, sometimes the same name is used in more than one file,
            causing a name collision for Intent Compiler components like <strong class="emphasis">ServGen</strong> that
            simultaneously operate on multiple
            YAML files within the same namespace. The <code class="clr-code">–rename-yaml</code> option. Specifies the
            prefix of a YAML file separated
            from a string by a colon “:” that is then prepended to every class name in the specified YAML.
            <br/><br/>
            As an
            example, a class named <code class="clr-code">Message</code> exists in both vmc-api-doc.yaml as well as
            ngw-api-doc.yaml but they are not
            the same object. To resolve this name collision, <code class="clr-code">--rename-yaml=ngw:NGW</code>
            prepends <code class="clr-code">NGW</code> to every class in
            <code class="clr-code">ngw-api-doc.yaml</code>, so that <code class="clr-code">Message</code> is renamed to
            <code class="clr-code">NGWMessage</code> in ngw-api-doc.yaml, while leaving Message
            unchanged in vmc-api-doc.yaml, thus avoiding the name collision.
        </td>
    </tr>

    <tr>
        <td class="left flag">-S | --single-file</td>
        <td class="flag-value">
            When this option is selected, all the output from APIGen is sent to a single file, including all models and
            API classes with their respective methods. If this option is skipped, each Class, Enum, and API Class is
            created in its own file, with the file name being the same as the Class/Enum it contains. Note: this latter
            requires that the <code class="clr-code">–output</code> option above be used to specify the folder in which
            these Class files will be
            created.
            <br/><br/>
            <div class="alert alert-info" role="alert">
                <div class="alert-items">
                    <div class="alert-item static">
            <span class="alert-text">
                Currently, this option <strong class="emphasis">must</strong> be provided for Typescript, and must not be provided for Java.
            </span>
                    </div>
                </div>
            </div>


        </td>
    </tr>

    <tr>
        <td class="left flag">-s &lt;yaml suffix string&gt; | --suffix=&lt;yaml suffix string&gt;</td>
        <td class="flag-value">
            Because libswagger currently processes either Swagger 2.0 or OpenApi 3.0 files, they are expected to have
            the common suffix pattern for YAML files at VMware: <code class="clr-code">-api-doc.yaml</code> (e.g. vmc-
            <code class="clr-code">api-doc.yaml</code>). In anticipation
            that libswagger will, in future, process a diversity of specification files, e.g. Protocol Buffers (.proto)
            ), this option allows for an alternate suffix to be specified for them. APIGen, and, in fact, all the Intent
            Compiler components rely on the pattern of the input files in order to create output files. Consequently,
            vmc-api-doc.yaml would allow a file called <code class="clr-code">vmc</code>-api.ts to be autogenerated.
        </td>
    </tr>

    <tr>
        <td class="left flag">-t | --trace</td>
        <td class="flag-value">
            Used by APIGen developers to emit trace level output.
        </td>
    </tr>

    <tr>
        <td class="left flag">-u | --full-uri</td>
        <td class="flag-value">
            Without this option, APIGen will only present the path portion of the API endpoint to the apiBridge.
            This is a required option for the Java version since the Java apiBridge requires a fully formed
            URI including the scheme and host obtained from the API specification document.
        </td>
    </tr>

    <tr>
        <td class="left flag">-V | --version</td>
        <td class="flag-value">
            Displays APIGen version.
        </td>
    </tr>

    <tr>
        <td class="left flag">-v | --verbose</td>
        <td class="flag-value">
            Used by APIGen developers to emit verbose level output.
        </td>
    </tr>

    <tr>
        <td class="left flag">-w | --no-warnings</td>
        <td class="flag-value">
            option suppresses warning from APIGen (not recommended, except while debugging, and overwhelmed by a stream
            of warnings).
        </td>
    </tr>

    <tr>
        <td class="left flag">-x | --no-null-object  </td>
        <td class="flag-value">
            Normally, when an API call returns nothing, APIGen creates an empty object and returns that. Sometimes, it is preferable
            not to have anything returned (i.e. <code class="clr-code">undefined</code>) rather than a <code class="clr-code">null</code>
            or an empty object, and this flag specifies doing just that.
        </td>
    </tr>

    </tbody>
</table>


<hr/>

<h2>
   Example Use
</h2>

<h3>
    VMC UI using Typescript with vmc-api-doc.yaml
</h3>
<pre class="code"><code class="language-bash" ngNonBindable>apigen -b ~/ui -p src/services/api -R ngw:NGW --single-file --output=vmc-api.ts vmc</code></pre>



<h3>
    AppFabric sample using Java with vmc-api-doc.yaml
</h3>
<pre class="code"><code class="language-bash" ngNonBindable> apigen -l java -L -o ~/appfabric/java/src/main/java/samples/api/vmc \
        -P samples.api.vmc -p src/main/java/samples/api -b ~/appfabric/java vmc
</code></pre>
