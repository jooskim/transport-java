package com.vmware.bifrost.core.autogen;


import com.vmware.bifrost.bridge.Request;
import com.vmware.bifrost.bridge.Response;
import com.vmware.bifrost.bus.model.Message;
import com.vmware.bifrost.core.AbstractService;
import com.vmware.bifrost.core.error.RestError;
import com.vmware.bifrost.core.model.RestOperation;
import lombok.Getter;
import lombok.Setter;
import org.springframework.http.HttpMethod;

import java.net.URI;
import java.util.function.Consumer;


/*
  AbstractAutoService is the parent class for all autogenerated services.

  @param <RequestType> The service request object
  @param <ResponseType> The service response object
 */
@SuppressWarnings({"unchecked", "WeakerAccess"})
public abstract class AbstractAutoService<RequestType extends Request, ResponseType extends Response>
        extends AbstractService<RequestType, ResponseType> {

    @Getter @Setter
    protected String apihost = null;                    // String for modifying URI by prepending this as hostname

    public static final Integer SERVICE_ERROR = 505;    // Used by servgen

    protected IRestApiBridge<RequestType, ResponseType> restApiBridge;
    protected RestError serviceError;

    public AbstractAutoService(String serviceChannel) {
        super(serviceChannel);
        this.serviceError = new RestError("Invalid Service APIRequest!", SERVICE_ERROR);

        this.initializeRestApiHandling();       // create the restApiBridge lambda
    }

    /**
     * This initializes the lambda for calls from the API layer to the transport layer
     */
    private void initializeRestApiHandling() {
        this.restApiBridge = (
                final IApiType<RequestType, ResponseType> apiType,
                final HttpMethod method,
                String uri,
                final String jsonBody,
                final IApiSuccessHandler<RequestType, ResponseType> successHandler,
                final IApiFailureHandler failureHandler,
                final String apiClassName,
                final Message message
        ) -> {

            // Services like NSX-T dynamically change the host for their API. By setting apihost in the derived service,
            // the URI passed to RestService is modified to prepend an alternate host. This can be done prior to every
            // API call. It is the responsibility of the derived service to reset this to null after the call returns.

            if (this.apihost != null) {
                uri = this.apihost + uri;
            }

            Consumer restResponse = (Object payload) -> successHandler.apiSuccessHandler(
                    apiType,
                    payload.toString(),
                    message     // this contains the UUID of the original caller to the autogenerated service
            );

            Consumer<RestError> restError = (RestError err) -> failureHandler.apiFailureHandler(
                    apiType,
                    err,
                    message     // this contains the UUID of the original caller to the autogenerated service
            );

            RestOperation restOp = new RestOperation();
            restOp.setApiClass(apiClassName);
            restOp.setMethod(method);
            restOp.setUri(URI.create(uri));
            restOp.setBody(jsonBody);
            restOp.setSentFrom(this.getName());
            restOp.setSuccessHandler(restResponse);
            restOp.setErrorHandler(restError);
            this.restServiceRequest(restOp);
        };
    }

    /**
     * This is called at the bottom of a service request to send a successful response with a payload to the consumer
     *
     * @param apiType opaque packaging of request and response objects
     * @param payload response payload
     * @param message Message
     */
    protected void apiSuccessHandler(IApiType<RequestType, ResponseType> apiType, String payload, Message message) {
        apiType.getResponseType().setPayload(payload);
        this.postResponse(apiType.getRequestType().getChannel(), apiType.getResponseType(), message);
    }

    /**
     * This is called when there is an error encountered by the service while handling a request - typically from the API call
     *
     * @param apiType opaque packaging of request and response objects
     * @param err     RestError
     * @param message Message
     */
    protected void apiFailureHandler(IApiType<RequestType, ResponseType> apiType, RestError err, Message message) {
        this.postError(apiType.getRequestType().getChannel(), err, message);
    }

    /**
     * Helper function to generate an API object
     *
     * @param req  request object
     * @param resp response object
     * @return ApiType
     */
    protected ApiType genApiObject(RequestType req, ResponseType resp) {
        return new ApiType(req, resp);
    }

    /**
     * Broadcast message to all subscribers on channel.
     *
     * @param channel broadcast channel
     * @param payload object to transmit
     */
    protected void broadcastResponse(String channel, Object payload) {
        this.bus.sendResponseMessage(channel, payload);
    }

    /**
     * Alias for broadcastResponse()
     *
     * @param channel broadcast channel
     * @param payload object to transmit
     */
    protected void broadcastNotification(String channel, Object payload) {
        this.broadcastResponse(channel, payload);
    }

    /**
     * Method to send a response object to the client of the service
     *
     * @param channel  response channel
     * @param response payload
     * @param message  Message
     */
    protected void postResponse(String channel, ResponseType response, Message message) {
        this.bus.sendResponseMessageWithId(channel, response, message.getId());
    }

    /**
     * Method to send a RestError to the client of the service
     *
     * @param channel response channel
     * @param err     RestError
     * @param message Message
     */
    protected void postError(String channel, RestError err, Message message) {
        this.bus.sendErrorMessageWithId(channel, err, message.getId());
    }

    /**
     * RestError to use for invalid requests
     *
     * @return RestError
     */
    protected RestError serviceRequestError() {
        return this.serviceError;
    }
}
