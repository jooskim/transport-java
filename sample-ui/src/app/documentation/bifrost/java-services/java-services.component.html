<appfab-java-badges></appfab-java-badges>
<h1>Building Services</h1>
<p>
    There are two ways to create services. The first is manually (which is what we're going to do next). The second is
    via auto-generation using the SewingMachine.
</p>
<p>
    A core philosophy of the application fabric, is that business logic and boilerplate code that operates with API's and infrastructure,
    should be un-managed, autogenerated code that is created from strongly defined specifications. Building services manually
    may make sense for your use case, <span class="emphasis">But it isn't required</span>.
</p>

<p>
    To get started, we should create a new class called <code
    class="clr-code">PongService</code>.
</p>
<p>
    The first thing we need to do in order to create our first simple <code class="clr-code">PongService</code> is
    create a <code class="clr-code">PongServiceRequest</code> model and a
    <code class="clr-code">PongServiceResponse</code> model. These two models are responsible for allowing other actors
    to know what to send to our service, and what to expect in response.
</p>

<h3>Java PongService</h3>
<pre class="code"><code class="language-java" ngNonBindable>
import com.vmware.bifrost.bridge.Request;
import com.vmware.bifrost.bridge.Response;
import com.vmware.bifrost.bus.Transaction;
import com.vmware.bifrost.bus.model.Message;
import com.vmware.bifrost.core.AbstractService;
import com.vmware.bifrost.core.util.ClassMapper;
import org.springframework.stereotype.Component;
import samples.CalendarService;

import java.util.UUID;

@Component
public class PongService extends AbstractService&lt;Request&lt;String&gt;, Response&lt;String&gt;&gt; &#123;
    // define the channel the service operates on,.
    public static final String Channel = "services-PongService";

    PongService() &#123;
        super(PongService.Channel);
    &#125;

    protected void handleServiceRequest(Request request, Message busMessage) &#123;

        // which command shall we run?
        switch(request.getRequest()) &#123;
            case PongRequestType.Basic:
                this.handleBasicPongRequest(request);
                break;

            case PongRequestType.Full:
                this.handleFullPongRequest(request);
                break;
        &#125;
    &#125;

    /**
     * Handle requests for basic pong needs
     * @param request The request being sent over the bus.
     */
    private void handleBasicPongRequest(Request request) &#123;

        // prepare and send a basic response.
        Response&lt;String&gt; response = new Response&lt;&gt;(request.getId(), "Fabric Pong (Basic): Pong");
        this.sendResponse(response, request.getId());
    &#125;

    /**
     * Handle requests for full pong needs.
     * @param request the request being sent over the bus.
     */
    private void handleFullPongRequest(Request request) &#123;

        UUID transactionId = request.getId();

        // call our calendar service and get a date and time, in two separate synchronous calls via transaction, pass
        // in our request ID as the transaction ID, so it can be tracked correctly across service calls.
        Transaction transaction = bus.createTransaction(Transaction.TransactionType.SYNC, "calendar-transaction", transactionId);

        // queue up requests for time and date via Calendar Service.
        transaction.sendRequest(CalendarService.Channel, new Request&lt;String&gt;(transactionId, "date")); // request date
        transaction.sendRequest(CalendarService.Channel, new Request&lt;String&gt;(transactionId, "time")); // request time

        // register complete handler for transaction.
        transaction.onComplete(
                (Message[] responses) -&gt; &#123;

                    // concatenate service responses into a string.
                    StringBuilder dateAndTime = new StringBuilder();
                    for(Message msg: responses) &#123;
                        String calendarResponse = ClassMapper.CastPayload(String.class, (Response)msg.getPayload());
                        dateAndTime.append(calendarResponse + " "); // add each response together.
                    &#125;

                    // prepare a response, with our date and time requests stuck together as a more elaborate response.
                    Response&lt;String&gt; response = new Response&lt;&gt;(request.getId(),
                            "Fabric Pong (Full): Pong++ " + dateAndTime.toString());
                    this.sendResponse(response, request.getId());
                &#125;
        );

        // commit transaction.
        transaction.commit();
    &#125;
&#125;

abstract class PongRequestType &#123;
    static final String Basic = "Basic";
    static final String Full = "Full";
&#125;
</code></pre>

<appfab-tryitout-component>
    <ping-fabric-component></ping-fabric-component>
</appfab-tryitout-component>



<!--<h3>Create Service Request/Response Models.</h3>-->
<!--<pre class="code"><code class="language-typescript" ngNonBindable>import &#123; ChannelName &#125; from '@vmw/bifrost';-->

<!--export const PongServiceChannel: ChannelName = 'services::PongService';-->

<!--export enum PongRequestType &#123;-->
    <!--Basic,-->
    <!--Full-->
<!--&#125;-->

<!--export interface PongServiceRequest &#123;-->
    <!--command: PongRequestType;-->
    <!--message: string;-->
<!--&#125;-->

<!--export interface PongServiceResponse &#123;-->
    <!--value: string;-->
<!--&#125;</code></pre>-->

<!--<p>-->
    <!--Pretty simple right? We have defined a channel on which to talk, an enum to define the command we want to send and-->
    <!--then two simple interfaces that define request and responses.-->
    <!--You're not restricted to interfaces here, you can also use classes. The important thing to remember here is that-->
    <!--this is <strong>*ALL*</strong> that is required in order to-->
    <!--talk to our new <code class="clr-code">PongService</code>.-->
<!--</p>-->

<!--<p>-->
    <!--Next, lets create our actual <code class="clr-code">PongService</code>. It looks like this:-->
<!--</p>-->

<!--<hr/>-->

<!--<h3>PongService</h3>-->
<!--<pre class="code"><code class="language-typescript" ngNonBindable>import &#123; AbstractService &#125; from '@vmw/bifrost/core';-->
<!--import &#123; EventBus, MessageArgs &#125; from '@vmw/bifrost';-->
<!--import &#123;-->
    <!--PongRequestType,-->
    <!--PongServiceChannel,-->
    <!--PongServiceRequest,-->
    <!--PongServiceResponse-->
<!--&#125; from './pong.service.model';-->

<!--export class PongService extends AbstractService&lt;PongServiceRequest, PongServiceResponse&gt; &#123;-->

    <!--constructor() &#123;-->

        <!--// identify the name of this service, and the channel it operates on.-->
        <!--super('PongService', PongServiceChannel);-->

        <!--// log that the service is online (if logging enabled)-->
        <!--this.log.info('PongService Loaded');-->
    <!--&#125;-->

    <!--/**-->
     <!--* Handle a request send on the service channel.-->
     <!--* @param request the request object-->
     <!--* @param args automatically passed by superclass, important details within.-->
     <!--*/-->
    <!--protected handleServiceRequest(request: PongServiceRequest, args?: MessageArgs): void &#123;-->

        <!--switch (request.command) &#123;-->
            <!--case PongRequestType.Basic:-->
                <!--this.handleBasicRequest(request.message, args);-->
                <!--break;-->

            <!--case PongRequestType.Full:-->
                <!--this.handleFullRequest(request.message, args);-->
        <!--&#125;-->
    <!--&#125;-->

    <!--/**-->
     <!--* Handle a basic request (limited details)-->
     <!--* @param message this is the message sent by the requesting actor.-->
     <!--* @param args these are important values that identify who sent the request.-->
     <!--*/-->
    <!--private handleBasicRequest(message: string, args: MessageArgs): void &#123;-->

        <!--const basicResponse = &#123;-->
            <!--value: `pong '$&#123;message&#125;'`-->
        <!--&#125;;-->

        <!--// send a response to whomever requested it.-->
        <!--this.postResponse(PongServiceChannel, basicResponse, args);-->
    <!--&#125;-->

    <!--/**-->
     <!--* Handle a more detailed response (more details)-->
     <!--* @param message this is the message sent by the requesting actor.-->
     <!--* @param args these are important values that identify who sent the request.-->
     <!--*/-->
    <!--private handleFullRequest(message: string, args: MessageArgs): void &#123;-->

        <!--// get a timestamp.-->
        <!--const date = new Date();-->
        <!--const dateString = date.toLocaleDateString('en-US');-->
        <!--const perf = performance.now();-->

        <!--const basicResponse = &#123;-->
            <!--value: `pong '$&#123;message&#125;' (on $&#123;date&#125; by event bus with id $&#123;EventBus.id&#125;) time: $&#123;perf&#125;`-->
        <!--&#125;;-->

        <!--// send a response to whomever requested it.-->
        <!--this.postResponse(PongServiceChannel, basicResponse, args);-->

    <!--&#125;-->
<!--&#125;</code></pre>-->
<!--<p>-->
    <!--Now we can load <code class="clr-code">PongService</code> whenever we like.-->
<!--</p>-->

<!--<hr/>-->

<!--<h3 id="loadingservice">Loading Services</h3>-->

<!--<p>-->
    <!--To load a service you can use the in-built static <code class="clr-code">ServiceLoader</code>-->
    <!--utility. The <code class="clr-code">ServiceLoader</code> takes the service class type as the first argument, and-->
    <!--then as many other constructor properties as you need for your service (variable args). In this example, we could load our-->
    <!--service at the same time we boot the bus (i.e. before Angular even loads).-->
<!--</p>-->
<!--<p>-->
    <!--We could also load the service on demand when it's required, by loading the service as a part of a module definition.-->
    <!--It's really up to you. The general rule is that a global service, should be ready before your application boots, other services can be booted on demand.-->
<!--</p>-->
<!--<p>-->
    <!--How do I boot <code class="clr-code">PongService</code>? Easy. Just pass your class to <code class="clr-code">ServiceLoader</code>.-->
    <!--Just like this:-->
<!--</p>-->

<!--<h3>Using ServiceLoader</h3>-->
<!--<pre class="code"><code class="language-typescript" ngNonBindable>import &#123; ServiceLoader &#125; from '@vmw/bifrost/util/service.loader';-->

<!--ServiceLoader.addService(PongService);</code></pre>-->

<!--<p>-->
    <!--If you want to create a service that accepts constructor arguments, and you want to pass them to the service loader? You can just add your constructor args-->
    <!--to the  <code class="clr-code">AddService</code> method.-->
<!--</p>-->

<!--<h3>Using ServiceLoader with constructor args</h3>-->
<!--<pre class="code"><code class="language-typescript" ngNonBindable>...-->
    <!--constructor(arg1, arg2, arg3) &#123;-->
<!--...-->

<!--ServiceLoader.addService(PongService, arg1, arg2, arg3);</code></pre>-->

<!--<p>-->
    <!--Once the service has loaded, you should see some output in the developer console, that looks something like...-->
<!--</p>-->
<!--<pre>▫️️<span class="console-purple">[Inf]:</span> 🌎 <span class="console-pink">Service Adaptor: PongService (3e4f3014) online and listening on 'services::PongService'</span> <span class="console-who">[PongService]</span> <span class="console-time">(9:25:39 AM)</span>-->
<!--▫️️<span class="console-purple">[Inf]:</span> <span class="console-pink">PongService Loaded</span>-->
<!--</pre>-->
