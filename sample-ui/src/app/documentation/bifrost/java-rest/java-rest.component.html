<appfab-java-badges></appfab-java-badges>
<h1>Making RESTful API Requests</h1>

<p>
  At some point (pretty quickly) you will need to start making remote calls to APIs in order to do interesting things.
</p>
<p>
  The Bifröst provides a built-in service that abstracts the need to be concerned with handling HTTP operations. The Java version of the RestService is a little
  more advanced than the TypeScript version.
</p>
<p>
  The Java version of <code class="clr-code">RestService</code> knows how to make remote calls to external URIs, as well as knowing how to make calls to local
  Rest Controllers in your existing application.
</p>
<p>
  The <code class="clr-code">RestService</code> provides operations for <code class="clr-code">GET, PUT, POST,
  PATCH</code> and <code class="clr-code">DELETE</code> RESTful RPC calls.
  It can be called from your service when you extend from <code class="clr-code">AbstractService</code>. It can also
  be called from your class when you extend from
  <code class="clr-code">AbstractBase</code>.
</p>

<h4 class="emphasis">
  The <code class="clr-code">RestService</code> uses <strong>Fetch</strong> to make HTTP calls, not XHR.
</h4>
<p>
  If you see XHR requests being made by your application in your developer console network activity - it's not being made by the fabric.
</p>

<hr/>

<h3>Loading the RestService</h3>

<p>
  Ideally, you want your <code class="clr-code">RestService</code> to boot when your application boots. This allows your application to start making
  remote calls and setting up state, before your UI framework has even loaded. This means it would be most suited
  very close to where you actually boot the event bus.
</p>
<p>
  In Angular applications, this would be in your <code class="clr-code">main.ts</code> file. Like with Services you build yourself, you would use the
  <code class="clr-code">ServiceLoader</code> to instantiate and boot the <code class="clr-code">RestService</code> and start it listening for requests.
</p>


<h3>Loading RestService</h3>
<pre class="code"><code class="language-typescript" ngNonBindable>import &#123; ServiceLoader &#125; from '@vmw/bifrost/util/service.loader';
import &#123; RestService &#125; from '@vmw/bifrost/core/services/rest/rest.service';

ServiceLoader.addService(RestService);</code></pre>

<p>
  Now the <code class="clr-code">RestService</code> is loaded and ready for any actor in your application that wants
  to make API calls. You should see the following in your developer console (if you have logging enabled)<br/>
</p>

<pre>▫️️ <span class="console-purple">[Inf]:</span> <span class="console-pink">RESTService Online</span></pre>

<hr/>

<h3>Calling RestService from your Service</h3>

<p>
  When your service extends from <code class="clr-code">AbstractService</code>, a method named <code class="clr-code">restServiceRequest()</code>
  is provided to your service. This method takes a single argument, a <code class="clr-code">RestOperation</code>
</p>
<p>
  This interface defines essential properties required in order to make the Remote HTTP call, like the URI, the HTTP Method,
  any body or headers to be set. The interface is defined as:
</p>

<pre class="code"><code class="language-typescript" ngNonBindable>export interface RestOperation &#123;
    id?: UUID;
    uri: string;
    method: HttpRequest;
    body?: any;
    pathParams?: any;
    queryParams?: any;
    headers?: any;
    successHandler: MessageFunction&lt;any&gt;
    errorHandler?: MessageFunction&lt;any&gt;
&#125;</code></pre>

<p>
  The only *required* properties are <code class="clr-code">uri, method, successHandler</code>. Everything else is optional.
  the success and error handlers, are lambda's you want called with the successful/failed response
  sent back by the API you just called.
</p>

<p>
  An example of what a GET request for a sample URI would look like from your component or service.
</p>

<pre class="code"><code class="language-typescript" ngNonBindable>this.restServiceRequest(
    &#123;
        uri: 'http://somehost/some-api',
        method: HttpRequest.Get,
        successHandler: (myresult: Array&lt;SomeObject&gt; => &#123;
            // do something interesting with the result
        &#125;
    &#125;
);
</code></pre>

<hr/>

<p>
  Let's create a simple service called <code class="clr-code">MyAPIService</code> that calls a remote API via the
  <code class="clr-code">RestService</code>
</p>



<h3>MyAPIService</h3>
<pre class="code"><code class="language-typescript" ngNonBindable>import &#123; AbstractService &#125; from '@vmw/bifrost/core';
import &#123; MessageArgs &#125; from '@vmw/bifrost';
import &#123; MyAPIServiceChannel, MyAPIServiceRequest, MyAPIServiceResponse &#125; from './myapi.service.model';
import &#123; HttpRequest, RestError &#125; from '@vmw/bifrost/core/services/rest/rest.model';
import &#123; ChannelName &#125; from '@vmw/bifrost';

export const MyAPIServiceChannel: ChannelName = 'services::MyAPIService';

export interface MyAPIServiceRequest &#123;
    id: number;
&#125;

export interface MyAPIServiceResponse &#123;
    message: string;
&#125;

export class MyAPIService extends AbstractService&lt;MyAPIServiceRequest, MyAPIServiceResponse&gt; &#123;

    constructor() &#123;

        // identify the name of this service, and the channel it operates on.
        super('MyAPIService', MyAPIServiceChannel);

        // log that the service is online (if logging enabled)
        this.log.info('MyAPIService Loaded');
    &#125;

    /**
     * Handle a request send on the service channel.
     * @param request the request object
     * @param args automatically passed by superclass, important details within, must include!
     */
    protected handleServiceRequest(request: MyAPIServiceRequest , args?: MessageArgs): void &#123;

        // call an API out there on the internets.
        this.restServiceRequest(
            &#123;
                uri: `https://jsonplaceholder.typicode.com/todos/$&#123;request.id&#125;`,
                method: HttpRequest.Get,
                successHandler: (response: any) =&gt; &#123;
                    this.postResponse(MyAPIServiceChannel, &#123; message: response.title &#125;, args);
                &#125;,
                errorHandler: (error: RestError) =&gt; &#123;
                    this.postError(MyAPIServiceChannel, error, args);
                &#125;
            &#125;,
            this.getName()
        );
    &#125;
&#125;
</code>
</pre>

<p>
  <code class="clr-code">MyAPIService</code> makes a very simple API request to a simple public API (no CORS
  restrictions). If there is a successful response (200), then the
  <code class="clr-code">successHandler()</code> is called and the service posts a response to the requester.
</p>
<p>
  To call <code class="clr-code">MyAPIService</code>, let's create a new component called <code class="clr-code">MyAPIComponent</code>
  that will call our new service.
</p>

<h3>MyAPIComponent</h3>
<pre class="code"><code class="language-typescript" ngNonBindable>import &#123; AbstractBase &#125; from '@vmw/bifrost/core';
import &#123; Component &#125; from '@angular/core';
import &#123; MyAPIServiceChannel, MyAPIServiceRequest, MyAPIServiceResponse &#125; from './myapi.service.model';
import &#123; ClrLoadingState &#125; from '@clr/angular';

@Component(&#123;
    selector: 'myapi-component',
    template: `
        &lt;button (click)="requestAPI()"  [clrLoading]="iconState"&gt;Request API&lt;/button&gt;&lt;br/&gt;
        Response: &#123;&#123;response&#125;&#125;`
&#125;)
export class MyAPIComponent extends AbstractBase &#123;

    public response = 'nothing yet, request something!';
    public iconState: ClrLoadingState = ClrLoadingState.DEFAULT;

    constructor() &#123;
        super('MyAPIComponent');
    &#125;

    /**
     * Send a request to MyAPI Service
     */
    public requestAPI(): void &#123;
        this.iconState = ClrLoadingState.LOADING;

        // generate an ID between 1 and 10.
        const request: MyAPIServiceRequest = &#123;
            id:  Math.floor(Math.random() * (10 - 1 + 1)) + 1
        &#125;;

        this.bus.requestOnce(MyAPIServiceChannel, request)
            .handle(
                (response: MyAPIServiceResponse) =&gt; &#123;
                    this.response = response.message;
                    this.iconState = ClrLoadingState.DEFAULT;
                &#125;
            );
    &#125;
&#125;</code></pre>

<p>
  You can try it out below!
</p>
<appfab-tryitout-component>
  <myapi-component></myapi-component>
</appfab-tryitout-component>
