<h1>Service Adapter Specification</h1>

<h3>Specification Document: mocks.json</h3>

<p>
    By convention, <code class="clr-code">mocks.json</code> contains the specifications for generating language-neutral
    populated <code class="clr-code">mocks</code> of data structures for internal use by the Service Adapter, either for customized code,
    or for custom tests, as well as for testing components in the application space by requesting a mock in response to a request to a
    Service Adapter. A later chapter will discuss in detail the autogenerated code. Requesting a mock in response to a service
    request is covered in a later more advanced chapter.
</p>

<p>
    It should be noted that the autogenerated mocks are not exposed in the Service Adapter Interface (YAML), and therefore,
    such mocks are not directly accessible from the application layer. Moreover, mocks are currently not supported for
    Service Adapters written in Java. Currently, mocks can be accessed directly from Typescript application components
    if the Service Adapter is also written in Typescript. Obviously, this won't work for Service Adapters written
    in other languages. We are investigating whether we can autogenerate mocks via <strong class="emphasis">ModelGen</strong>
    in the application space to mimic those in the Service layer.
</p>

<p>
    It is worth pointing out that mock data structures are automatically generated, even in the absence of a <code class="clr-code">mocks.json</code>,
    for every class referred to in the Service Adapter, with default values for their properties based on their respective "type".
    So, <code class="clr-code">mocks.json</code> is only required to create custom mocks with specified values, or complex
    combination of one or more mocks.
</p>

<p>
    Here is an example of some mock specifications excerpted from the <strong class="emphasis">sddc-core</strong> Service Adapter:
</p>

<pre class="code"><code class="language-json" ngNonBindable>
&#123;
    "mocks": [
        &#123;
            "name": "ESX1",
            "class": "EsxHost",
            "properties": [
                &#123; "property": "name", "value": "Not Really ESX1" &#125;,
                &#123; "property": "hostname", "value": "zerocloud.esx.local1" &#125;,
                &#123; "property": "mac_address", "value": "01-23-45-67-89-ab" &#125;
           ]
        &#125;,
        &#123;
            "name": "ESX2",
            "clone": "ESX1",
            "properties": [
                &#123; "property": "name", "value": "Not Really ESX2" &#125;,
                &#123; "property": "hostname", "value": "zerocloud.esx.local2" &#125;,
                &#123; "property": "mac_address", "value": "01-23-45-67-89-ac" &#125;
           ]
        &#125;,
        &#123;
            "name": "ClusterWithPendingCloudDeletionHost",
            "class": "Cluster",
            "properties": [
                &#123; "property": "esx_host_list", "value": "MockESX1(), MockESX2()", "container": "array" &#125;
            ]
        &#125;,
        &#123;
            "name": "ClusterReconfigResponseWithEmptyCapacity",
            "class": "VsanClusterReconfigConstraints",
            "properties": [
                &#123;
                    "property": "available_capacities",
                    "container": "map",
                    "nested": "array",
                    "type": "VsanAvailableCapacity",
                    "value": "",
                    "empty": true
                &#125;
            ]
        &#125;,
        &#123;
            "name": "AwsInstanceAvailability",
            "map": "AwsProvisionMap",
            "properties": [
                &#123; "property": "eu-west-3", "value": "MockI3InstanceTypeConfig()", "container": "array" &#125;,
                &#123; "property": "eu-west-2", "value": "MockI3InstanceTypeConfig(), MockR5InstanceTypeConfig()", "container": "array" &#125;
            ]
        &#125;,
        &#123;
            "name": "DefaultSegment",
            "class": "Segment",
            "properties": [
                &#123;
                    "property": "resource_type",
                    "value": "Segment",
                    "type": "string",
                    "literal": true
                &#125;
            ]
        &#125;
</code></pre>

<p>
    In the above, we have specified that we want to create two mocked data structures named <code class="clr-code">ESX1</code> and <code class="clr-code">ESX2</code>,
    with the latter being <code class="clr-code">cloned</code> from the former. Additionally, we have specified a third complex mock called <code class="clr-code">ClusterWithPendingCloudDeletionHost
</code>,
    which is a completely different data structure, which populates one of its properties, <code class="clr-code">esx_host_list</code>, with an array
    containing the previous two mocks.
    <br/><br/>
    While the details of autogenerating mocks are discussed in a later advanced chapter, it should be noted that the result of specifying a mock is
    the instamtiation of a callable function which
    returns a populated data structure, and the specified name is prefixed with the string <strong class="emphasis">Mock</strong>. Also, when referring to such
    mocks in the specifications, they are suffixed by parentheses, e.g. <code class="clr-code">MockESX1()</code>.
</p>
<p>
    The following describes the properties used in the above example (there are more property details described further down in this chapter):
</p>
<table class="table table-noborder flag-table">
    <thead>
    <tr>
        <th class="left flag-header">Property</th>
        <th>Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td class="left flag">mocks</td>
        <td class="flag-value">This property specifies an array of custom mocked classes. These mocked classes are currently only accessible
            for Service Adapters written in Typescript. Moreover, the current implementation provides direct reference to these from the
            application space in Typescript. <code class="clr-code">This will change</code>. Work is underway to instantiate these mocked
            classes in the application space via <strong class="emphasis">ModelGen</strong>. The <code class="clr-code">forceResponse</code>
            function (described in a later advanced chapter) will be replaced by a bifr√∂st message. Until these changes are implemented, custom mocks are
            not supported in Java.
        </td>
    </tr>
    <tr>
        <td class="left flag">name</td>
        <td class="flag-value">This property specifies the name of a mocked class that is to be instantiated. This name is
            referable from the Service Adapter and its mocks and tests, but is not currently exposed in the Service Adapter Interface
            Document, but is in the roadmap to get there. When referring to this mock prefix the name with
            <strong class="emphasis">Mock</strong> and append parentheses: <strong class="emphasis">()</strong> which
            accesses the autogenerated mock function that returns the populated class. So, in order to access the above example mock named
            <strong class="emphasis">ESX1</strong>, refer to it as <code class="clr-code">MockESX1()</code> (except when cloning it,
            as described below).
        </td>
    </tr>
    <tr>
        <td class="left flag">class</td>
        <td class="flag-value">This property specifies the class being mocked. In the above example, <code class="clr-code">ESX1</code>
            is a custom mock that is instantiated using the class <code class="clr-code">EsxHost</code>.The mock is initially populated
            with default values for each of its properties, based on their respective "type". One or more of these properties can then be
            independently populated with custom values as described below.
        </td>
    </tr>
    <tr>
        <td class="left flag">map</td>
        <td class="flag-value">When the class being mocked is an <strong class="emphasis">ES6 Map</strong>, we use the property
            <code class="clr-code">map</code> instead of <code class="clr-code">class</code>, as shown in the above example for
            <code class="clr-code">AwsInstanceAvailability</code>.
        </td>
    </tr>
    <tr>
    <tr>
        <td class="left flag">clone</td>
        <td class="flag-value">This property specifies that a mocked class be instantiated as an exact copy of another mock so that one or
            more properties can be altered from that of the original mock. When this property is specified, then it is not necessary to
            specify the <strong class="emphasis">class</strong> property, as that property in the original class is used. In the above example,
            <code class="clr-code">ESX2</code> is cloned from <code class="clr-code">ESX1</code> and new values are specified for some
            of the properties, while keeping the rest of the properties the same as in the original mock.
        </td>
    </tr>
    <tr>
        <td class="left flag">properties</td>
        <td class="flag-value">This property specifies an array of mocked class properties that are to be populated with custom values as described in the next section of this chapter.
        </td>
    </tr>
    </tbody>
</table>
<hr/>
<h3>Specifying Mocked Class Properties</h3>
<p>
    Each property in a mocked class that is to be assigned a mock value has additional qualifier properties described in detail below:
</p>

<table class="table table-noborder flag-table">
    <thead>
    <tr>
        <th class="left flag-header">Property</th>
        <th>Description</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td class="left flag">property</td>
        <td class="flag-value">This is the name of the mocked  class' property to be populated with mock values. When the mock is for an
            <strong class="emphasis">ES6 Map</strong>, Each <code class="clr-code">property</code> is a key for the map entry,
            and <code class="clr-code">value</code>, described below, is the content for this key. See the end of this chapter for sample
            code that is autogenerated to mock <code class="clr-code">AwsInstanceAvailability</code>.
        </td>
    </tr>
    <tr>
        <td class="left flag">value</td>
        <td class="flag-value">This property specifies the content to be assigned to this property. In the example above
            for <code class="clr-code">ClusterWithPendingCloudDeletionHost</code>, the property <code class="clr-code">esx_host_list</code>
            is assigned an array containing the mocked classes <code class="clr-code">MockESX1()</code> and
            <code class="clr-code">MockESX2()</code>. Note how array elements are specified with comma separation. It is acceptable
            to set the <strong class="emphasis">value</strong> for a property in a mocked class to be <code class="clr-code">null</code>.
            See <strong class="emphasis">empty</strong> below for an
            example of how to set a property with a nested container to be empty.
        </td>
    </tr>
    <tr>
        <td class="left flag">type</td>
        <td class="flag-value">This property specifies the "type" of the <strong class="emphasis">value</strong> for this.
            The type specification uses <code class="clr-code">CommonType</code> (content/nested/type) described in previous chapters, using
            container/nested/type. The are a few additional type qualifiers such as <strong class="emphasis">literal</strong>
            and <strong class="emphasis">empty</strong>, etc., described below. Also, refer
            to the example above for <code class="clr-code">ClusterReconfigResponseWithEmptyCapacity</code>, where the
            <strong class="emphasis">value</strong> is an ES6 Map of an array of
            <strong class="emphasis"><strong class="emphasis">VsanAvailableCapacity</strong></strong>.
            As with all other specifications, if <code class="clr-code">type</code> is not specified, it is assumed to be
            <code class="clr-code">string</code>.
        </td>
    </tr>
    <tr>
        <td class="left flag">literal</td>
        <td class="flag-value">When assigning a value to a mocked class property, there can be ambiguity as to what is specified.
            Take the example above of the mock <code class="clr-code">DefaultSegment</code>, which mocks the <code class="clr-code">Segment</code>
            class. This mock tries to assign the string <strong class="emphasis">"Segment"</strong> to the
            <code class="clr-code">resource_type</code>. By setting <code class="clr-code">literal</code>, the specification tells
            <strong class="emphasis">ServGen</strong> not to try to infer whether <strong class="emphasis">Segment</strong> should
            be further analyzed to be a reference to be the class <code class="clr-code">Segment</code>, and to take the
            string <strong class="emphasis">literally</strong> and assign it as a quoted string, rather than as a variable or
            a constant.
        </td>
    </tr>
    <tr>
        <td class="left flag">empty</td>
        <td class="flag-value">For nested containers that need to be assigned to a mocked class' property, sometimes it is desirable
            to set the property to be empty. In the above example for the mock
            <code class="clr-code">ClusterReconfigResponseWithEmptyCapacity</code>, the property <code class="clr-code">available_capacities</code>,
            is an ES6 Map container, which boasts a nested array of type <code class="clr-code">VsanAvailableCapacity</code>. By setting
            <code class="language-json">"value": ""</code>, we are specifying that the array is empty, although the ES6 Map still contains
            the empty array. By further setting <code class="language-json">"empty": true</code>, we are specifying that the ES6 Map
            itself should have no content (in which case, setting <code class="language-json">"value": ""</code> is redundant.
        </td>
    </tr>
    <tr>
        <td class="left flag">key</td>
        <td class="flag-value">When an ES6 Map is mocked, it is instantiated with a default string for the key to the map.
            This property allows for a specified value for the map key.
        </td>
    </tr>
    </tbody>
</table>

<hr/>


<h3>Pro Tips</h3>

<p>
    Normally, <strong class="emphasis">Servgen</strong> pulls a class definition and includes it in the Service Interface Document that it
    outputs, so that the class can be declared in the application space by <strong class="emphasis">ModelGen</strong>, if the class is
    referred to in a service request parameter or response, if it is a class or its ancestor, or its
    property is a class or its ancestor.
</p>
<p>
    There is a desire, where some classes not captured by the
    above criterion needs to be included so that the application can refer to it. A typical example is
    when a polymorphic parent is included, but none of its polymorphic children are included in the
    Interfacve YAML. Mocking the desired class with no properties will get that class included.
    Here is an example:
</p>

<pre class="code"><code class="language-json" ngNonBindable>
&#123;
    "mocks": [
        &#123;
            "name": "YourMockName",
            "class": "AwsSddcResouceConfig",
        &#125;,
</code></pre>

<p>
    The above will pull in and expose access to the <code class="clr-code">AwsSddcResouceConfig</code> class via <strong class="emphasis">ModelGen</strong>
    to the application/component space.
</p>

<hr/>

<h3>Sample Autogenerated Mocks</h3>

<p>
    For Service Adapters written in Typescript, this is an example of code being autogenerated in
    the Service Adapter for a few mocked classes excerpted from above example specifications and added to the
    <strong class="emphasis">token</strong> Service Adapter which we have used as a simple example in previous chapters:
</p>

<pre class="code"><code class="language-typescript" ngNonBindable>

const DEFAULT_STRING = '# This is the default string for tests #';
const DEFAULT_INTEGER = 12345;
const DEFAULT_BOOLEAN = false;
const DEFAULT_OBJECT = &#123;&#125;;

export namespace TokenMocks &#123;
// Instantiated classes
    
    export function MockVsanAvailableCapacity(): VsanAvailableCapacity &#123;
        const json = Object.assign(&#123;&#125;, MockJsonVsanAvailableCapacity);
        const baseVsanAvailableCapacity = new BaseVsanAvailableCapacity(json);
        const newMock = VsanAvailableCapacity.factory(baseVsanAvailableCapacity);
        return newMock;
    &#125;

    // Mock for VsanClusterReconfigBias - generateMock
    export const MockJsonVsanClusterReconfigBias = &#123;

        id: DEFAULT_STRING,
        short_description: DEFAULT_STRING,
        full_description: DEFAULT_STRING,
    &#125;;
    
    // Mock for EsxHost - generateMock
    export const MockJsonEsxHost = &#123;
        // Polymorphic class parent - needs a custom default mock...
        // custom mock 'MockEsxHost()' will be returned in its place from token.rest.mock.

        availability_zone: DEFAULT_STRING,
        esx_id: DEFAULT_STRING,
        custom_properties: new Map&lt;string, string&gt;([[DEFAULT_STRING, DEFAULT_STRING]]),
        mac_address: DEFAULT_STRING,
        esx_state: DEFAULT_STRING,
        name: DEFAULT_STRING,
        esx_credential: MockCredential(),
        provider: DEFAULT_STRING,
        hostname: DEFAULT_STRING,
    &#125;;

    export function MockEsxHost(): EsxHost &#123;
        const json = Object.assign(&#123;&#125;, MockJsonEsxHost);
        const baseEsxHost = new BaseEsxHost(json);
        const newMock = EsxHost.factory(baseEsxHost);
        return newMock;
    &#125;

    // Mock for Segment - generateMock
    export const MockJsonSegment = &#123;

        display_name: DEFAULT_STRING,
        id: DEFAULT_STRING,
        parent_path: DEFAULT_STRING,
        path: DEFAULT_STRING,
        relative_path: DEFAULT_STRING,
        resource_type: DEFAULT_STRING,
        subnets: [MockSubnet()],
    &#125;;

    export function MockSegment(): Segment &#123;
        const json = Object.assign(&#123;&#125;, MockJsonSegment);
        const baseSegment = new BaseSegment(json);
        const newMock = Segment.factory(baseSegment);
        return newMock;
    &#125;

    export function MockVsanClusterReconfigConstraints(): VsanClusterReconfigConstraints &#123;
        const json = Object.assign(&#123;&#125;, MockJsonVsanClusterReconfigConstraints);
        const baseVsanClusterReconfigConstraints = new BaseVsanClusterReconfigConstraints(json);
        const newMock = VsanClusterReconfigConstraints.factory(baseVsanClusterReconfigConstraints);
        return newMock;
    &#125;

    // Mock for Cluster - generateMock
    export const MockJsonCluster = &#123;

        aws_kms_info: MockAwsKmsInfo(),
        disk_group_list: [MockVsanDiskGroup()],
        vsan_subcluster_uuid: DEFAULT_STRING,
        cluster_id: DEFAULT_STRING,
        cluster_name: DEFAULT_STRING,
        host_cpu_cores_count: DEFAULT_INTEGER,
        cluster_state: DEFAULT_STRING,
        cluster_vcenter_mo_id: DEFAULT_STRING,
        esx_host_list: [MockEsxHost()],
        volume_list: [MockStorageVolume()],
    &#125;;

    export function MockCluster(): Cluster &#123;
        const json = Object.assign(&#123;&#125;, MockJsonCluster);
        const baseCluster = new BaseCluster(json);
        const newMock = Cluster.factory(baseCluster);
        return newMock;
    &#125;

// Autogenerated Custom Mocks
    
    // Mock for Map AwsInstanceAvailability - generateCustomMapMock
    export function MockAwsInstanceAvailability(): Map&lt;string, Array&lt;InstanceTypeConfig&gt;&gt; &#125;
        const mockMap = AwsProvisionMap;
        mockMap.set('eu-west-3', [MockI3InstanceTypeConfig()]);
        mockMap.set('eu-west-2', [MockI3InstanceTypeConfig(), MockR5InstanceTypeConfig()]);
        return mockMap;
    &#125;
    
    // Mock for ESX1 - generateCustomMock
    export function MockESX1(): EsxHost &#123;
        const json = Object.assign(&#123;&#125;, MockJsonEsxHost);
        const baseEsxHost = new BaseEsxHost(json);
        // Properties for MockESX1
        // type: string
        baseEsxHost['name'] = 'Not Really ESX1';
        // type: string
        baseEsxHost['hostname'] = 'zerocloud.esx.local1';
        // type: string
        baseEsxHost['mac_address'] = '01-23-45-67-89-ab';
        const newMock = EsxHost.factory(baseEsxHost);
        return newMock;
    &#125;

    // Mock for ESX2 - generateCustomMock
    export function MockESX2(): EsxHost &#123;
        const json = Object.assign(&#123;&#125;, MockJsonEsxHost);
        const baseEsxHost = new BaseEsxHost(json);
        // Properties from MockESX1
        // Properties for MockESX2
        // type: string
        baseEsxHost['name'] = 'Not Really ESX2';
        // type: string
        baseEsxHost['hostname'] = 'zerocloud.esx.local2';
        // type: string
        baseEsxHost['mac_address'] = '01-23-45-67-89-ac';
        const newMock = EsxHost.factory(baseEsxHost);
        return newMock;
    &#125;

    // Mock for ClusterWithPendingCloudDeletionHost - generateCustomMock
    export function MockClusterWithPendingCloudDeletionHost(): Cluster &#123;
        const json = Object.assign(&#123;&#125;, MockJsonCluster);
        const baseCluster = new BaseCluster(json);
        // Properties for MockClusterWithPendingCloudDeletionHost
        // type: Array&lt;string&gt;
        baseCluster['esx_host_list'] = [MockESX1(), MockESX2()];
        const newMock = Cluster.factory(baseCluster);
        return newMock;
    &#125;

    // Mock for ClusterReconfigResponseWithEmptyCapacity - generateCustomMock
    export function MockClusterReconfigResponseWithEmptyCapacity(): VsanClusterReconfigConstraints &#123;
        const json = Object.assign(&#123;&#125;, MockJsonVsanClusterReconfigConstraints);
        const baseVsanClusterReconfigConstraints = new BaseVsanClusterReconfigConstraints(json);
        // Properties for MockClusterReconfigResponseWithEmptyCapacity
        // type: Map&lt;string, Array&lt; VsanAvailableCapacity &gt;&gt;
        baseVsanClusterReconfigConstraints['available_capacities'] = new Map&lt;string, Array&lt; VsanAvailableCapacity &gt;&gt;();
        const newMock = VsanClusterReconfigConstraints.factory(baseVsanClusterReconfigConstraints);
        return newMock;
    &#125;

    // Mock for DefaultSegment - generateCustomMock
    export function MockDefaultSegment(): Segment &#123;
        const json = Object.assign(&#123;&#125;, MockJsonSegment);
        const baseSegment = new BaseSegment(json);
        // Properties for MockDefaultSegment
        // type: string
        baseSegment['resource_type'] = 'Segment';
        const newMock = Segment.factory(baseSegment);
        return newMock;
    &#125;

&#125;

</code></pre>

<hr/>

<p>
    That's it! This is all you need to specify custom mocks. A chapter on advanced usage later will describe how you can get mocked
    data structures returned from service requests in tests, both in the service layer, as well as from the application layer.
</p>
