<h1>Service Adapter Specification</h1>

<h3>Service Adapter Specification Conventions.</h3>

<p>
    Specifications consumed by the various components of the Sewing Machine, be they API Specifications, Service Adapter Specification,
    or Application Specifications, constitute the <strong class="emphasis">language</strong> of the <strong class="emphasis">Intent Compiler</strong>.
    This section describes the specifications that comprise Service Adapter Specification documents.
</p>

<p>
    Specifications for a Service Adapter consist of providing a number of JSON objects in a file with the suffix <code class="clr-code">.json</code>
    in a sub-folder for that Service Adapter with the name <code class="clr-code">specs</code>. The name of the enclosing folder is the same as
    the name of the Service Adapter itself. i.e. The name of the <code class="clr-code">Token</code> Service Adapter is <code class="clr-code">token</code>
    for Service Adapters written in Typescript, as it is usual to write names in kebab-case there,
    and <code class="clr-code">Token</code> when written in Java, using PascalCase. If the Sewing Machine component,
    <strong class="emphasis">Specgen</strong> is used, it will take care of specifying the name in the casing appropriate
    for the language used for the Service Adapter.
</p>

<p>
    While it is possible to specify everything associated with a Service Adapter in a single file, this is not a recommended practice,
    and for readability, the convention is to place each <strong class="emphasis">type</strong> of specification in its own file.
    Similarly, while the compiler is agnostic
    to the name of the specification file(s) as long as they have <code class="clr-code">.json</code> for suffix in their name,
    the convention is to name them as described below, for consistency across all projects:
</p>
<table class="table table-noborder flag-table">
    <thead>
    <tr>
        <th class="left flag-header">File Name</th>
        <th>Specification Type</th>
    </tr>
    </thead>
    <tbody>
    <tr>
        <td class="left flag">service.json</td>
        <td class="flag-value">This file contains the main specification for a Service Adapter. At a minimum, it must specify
            <ul>
                <li>The name of the Service Adapter.</li>
                <li>The version of the Service Adapter.</li>
                <li>At least one request that the Service Adapter responds to, in addition to the autogenerated response to
                    <code class="clr-code">GetServiceVersion</code>, which exists in every Service Adapter.
                </li>
            </ul>
            <br/>
            There are many more specifications that can describe the Service Adapter in <strong class="emphasis">service.json</strong>, and they are described in detail
            in subsequent documents.
        </td>
    </tr>
    <tr>
        <td class="left flag">exports.json</td>
        <td class="flag-value">This file lists all the objects (classes) and enumerations that are owned by this Service Adapter and should be
            imported by other Service Adapters and defined by them.
        </td>
    </tr>
    <tr>
        <td class="left flag">imports.json</td>
        <td class="flag-value">This file lists all the objects (classes) and enumerations that this service imports from other Service
            Adapters that own them, rather than define them in this Service Adapter. The combination of <strong class="emphasis">exports.json</strong>
            and <strong class="emphasis">imports.json</strong> assures that there is only a single owner for objects and enumerations. This is important
            because the same API Specification documents, which define these objects in the first place, are accessible by multiple Service Adapters,
            and avoids duplication of object instantiation.
        </td>
    </tr>
    <tr>
        <td class="left flag">enums.json</td>
        <td class="flag-value">This file allows for enumerations "cloned" from those that appear in API Secification documents, to be "extended" in a
            language-neutral fashion, by adding additional enumerated fields. Additionally, new enumerations can be specified in a
            language-neutral way. Only "string enumerations" are supported.
        </td>
    </tr>
    <tr>
        <td class="left flag">class.json</td>
        <td class="flag-value">This file allows for objects (classes) defined in API Specification documents to be "extended"
            in a language-neutral way, by adding
            additional properties, complete with type specification using <code class="clr-code">CommonType</code> described in the
            <strong class="emphasis">Overview</strong> section. Additionally, a new class can be specified in a language-neutral way.
            <br/><br/>
            These classes are called <code class="clr-code">custom classes</code> and find there way into the Service Adapter Specification document
            for this Service Adapter, and can be used by consumer applications, as well as other Service Adapters.
        </td>
    </tr>
    <tr>
    <td class="left flag">maps.json</td>
    <td class="flag-value">This file allows for the definition of a language-neutral <code class="clr-code">map</code>, which is
        a container for unordered key/value pairs of arbitrary types as described in <code class="clr-code">CommonType</code>
        in the <strong class="emphasis">Overview</strong> section. A <code class="clr-code">map</code> data structure thus created
        can be used by this Service Adapters as well as other Service Adapters, however, it is not described in the Service Adapter
        Interface documents and cannot be consumed by applications.
    </td>
    </tr>
    <tr>
        <td class="left flag">sets.json</td>
        <td class="flag-value">In the context of the Sewing Machine, a <code class="clr-code">set</code> is a container with
            an unordered collection of objects that can be tested for their presence or absence in the container,
            and can be specified in a language-neutral way. This file allows for the specification of such sets, each of
            which contains objects of a specific type. A <code class="clr-code">set</code> data structure thus created
            can be used by this Service Adapters as well as other Service Adapters, however, it is not described in the Service Adapter
            Interface documents and cannot be consumed by applications.
        </td>
    </tr>
    <tr>
        <td class="left flag">arrays.json</td>
        <td class="flag-value">Arrays are analogous to <code class="clr-code">sets</code> in that they are also containers of objects,
            but are ordered in such a ways as to be sequentially or directly accessed in either direction as an ordered list of a
            specific type. An <code class="clr-code">array</code> data structure thus created
            can be used by this Service Adapters as well as other Service Adapters, however, it is not described in the Service Adapter
            Interface documents and cannot be consumed by applications.
        </td>
    </tr>
    <tr>
        <td class="left flag">mocks.json</td>
        <td class="flag-value">Every data structure that is either consumed or produced by a Service Adapter can be "mocked". i.e. a
            fully populated object can be autogenerated using either default or specified values for the properties it encompasses. This
            file allows for specifying a variety of using <code class="clr-code">mocked</code> data structures, including inheritance
            from other data structures and complex descriptions of these data structures (e.g. maps of arrays of classes). These data
            structures can then be provided to mocked responses to requests to the Service Adapter by a consuming application.
            Because the implementation of mocks are evolving, for now, these mocked data structures are not included in the Service
            Adapter Interface documents, and the application must "know" the name of each mocked data structure that it wishes
            to use during testing. Once the implementation of these mocked data structures is finalized, they will be described in the
            Service Adapter Interface Document, or, more likely, in a Mock Interface document.
        </td>
    </tr>
    <tr>
        <td class="left flag">testing.json</td>
        <td class="flag-value">This file allows for specifying hints on how to create autogenerated tests beyond the default case,
            including default responses from mocked Service Adapters.
        </td>
    </tr>
    </tbody>
</table>
<hr/>

