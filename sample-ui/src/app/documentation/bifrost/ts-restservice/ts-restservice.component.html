<appfab-typescript-badges></appfab-typescript-badges>
<h1>Making RESTful API Requests</h1>

<p>
    At some point (pretty quickly) you will need to start making remote calls to APIs in order to do interesting things.
</p>
<p>
    The Bifröst provides a built-in service that abstracts the need to be concerned with handling HTTP operations. It would be comparable to the
    <code class="clr-code">HttpClient</code> in an Angular application, except in this design, you don't directly talk to the HTTP client, you send a message to
    a <code class="clr-code">RestService</code> that will perform the operation for you and return the result.
</p>
<p>
    The fabric <code class="clr-code">RestService</code> design abstracts the need for your application to know or bind to a specific implementation. In fact, the original
    version of the <code class="clr-code">RestService</code> actually used the Angular <code class="clr-code">HttpClient</code>. Because of the decoupled design, we swapped out the original Angular client
    with a much simpler internal client that uses fetch instead of XHR.
</p>
<p>
    The <code class="clr-code">RestService</code> provides operations for <code class="clr-code">GET, PUT, POST,
    PATCH</code> and <code class="clr-code">DELETE</code> RESTful RPC calls.
    It can be called from your service when you extend from <code class="clr-code">AbstractService</code>. It can also
    be called from your component when you extend from
    <code class="clr-code">AbstractBase</code>.
</p>

<h4 class="emphasis">
     The <code class="clr-code">RestService</code> uses <strong>Fetch</strong> to make HTTP calls, not XHR.
</h4>
<p>
    If you see XHR requests being made by your application in your developer console network activity - it's not being made by the fabric.
</p>

<hr/>

<h3>Starting up the RestService</h3>

<p>
    Ideally, you want your <code class="clr-code">RestService</code> to boot when your application boots. This allows your application to start making
    remote calls and setting up state, before your UI framework has even loaded. This means it would be most suited
    very close to where you actually boot the event bus.
</p>
<p>
    In Angular applications, this would be in your <code class="clr-code">main.ts</code> file. Like with Services you build yourself, you would use the
    <code class="clr-code">ServiceLoader</code> to instantiate and boot the <code class="clr-code">RestService</code> and start it listening for requests.
</p>


<h3>Loading RestService</h3>
<pre class="code"><code class="language-typescript" ngNonBindable>import &#123; ServiceLoader &#125; from '@vmw/bifrost/util/service.loader';
import &#123; RestService &#125; from '@vmw/bifrost/core/services/rest/rest.service';

ServiceLoader.addService(RestService);</code></pre>

<p>
    Now the <code class="clr-code">RestService</code> is loaded and ready for any actor in your application that wants
    to make API calls. You should see the following in your developer console (if you have logging enabled)<br/>
</p>

<pre>▫️️ <span class="console-purple">[Inf]:</span> <span class="console-pink">RESTService Online</span></pre>

<hr/>

<h3>
    Setting global headers for RestService calls.
</h3>

<p>
    Sometimes there is a need to set headers for all Rest operations. This is most commonly setting a 'Content-Type' or a csp-auth-token
    or something. The good news is that there is a built in mechanism for this. It is made available by <code class="clr-code">AbstractBase</code>.
    It is named <code class="clr-code">setGlobalHttpHeaders()</code>.
</p>

<pre class="code"><code class="language-typescript" ngNonBindable>this.setGlobalHttpHeaders( &#123;'Content-Type': 'application/json'&#125; )</code></pre>

<p>
    The method takes an object, you can put as man headers in here as you like.
</p>
<hr/>

<h3>
    Changing RestService host options
</h3>

<p>
    Sometimes you need to change host details for API calls. You might want to call a different host defined by the API, or change scheme.
    The good news is that there is a built in mechanism for this. It is made available by <code class="clr-code">AbstractBase</code>.
    It is named <code class="clr-code">setGlobalRestServiceHostOptions()</code>.
</p>

<pre class="code"><code class="language-typescript" ngNonBindable>this.setGlobalRestServiceHostOptions('subdomain.somehost.com', 'http')</code></pre>

<p>
    You can set a different host for all <code class="clr-code">RestService</code> calls. In the above example, we also override the scheme to 'http'
</p>
<hr/>


<h3>Making a Rest Call for any API.</h3>

<p>
    When your service extends from <code class="clr-code">AbstractService</code>, a method named <code class="clr-code">restServiceRequest()</code>
    is provided to your service. This method takes a single argument, a <code class="clr-code">RestOperation</code>
</p>
<p>
    This interface defines essential properties required in order to make the Remote HTTP call, like the URI, the HTTP Method,
    any body or headers to be set. The interface is defined as:
</p>

<pre class="code"><code class="language-typescript" ngNonBindable>export interface RestOperation &#123;
    id?: UUID;
    uri: string;
    method: HttpRequest;
    body?: any;
    pathParams?: any;
    queryParams?: any;
    headers?: any;
    successHandler: MessageFunction&lt;any&gt;
    errorHandler?: MessageFunction&lt;any&gt;
&#125;</code></pre>

<p>
    The only *required* properties are <code class="clr-code">uri, method, successHandler</code>. Everything else is optional.
    the success and error handlers, are lambda's you want called with the successful/failed response
    sent back by the API you just called.
</p>

<p>
    An example of what a GET request for a sample URI would look like from your component or service.
</p>

<pre class="code"><code class="language-typescript" ngNonBindable>this.restServiceRequest(
    &#123;
        uri: 'http://somehost/some-api',
        method: HttpRequest.Get,
        successHandler: (myresult: Array&lt;SomeObject&gt; => &#123;
            // do something interesting with the result
        &#125;
    &#125;
);
</code></pre>

<hr/>

<h3>How can I call the Fabric/Non Browser version of the RestService?</h3>

<h5>Need to bypass all browser CORS and security restrictions? Need a clean way to make any REST API call to anywhere from the browser? </h5>

<p>
    The Fabric comes with a counter-part <code class="clr-code">RestService</code>. This means you can bypass all the browser security restrictions
    placed on your application by CORS. You can fire your Restful API call via the Backend (Java). You don't need to change anything, the existing
    methods work.
</p>

<p>
    In order to use the Java Bifröst <code class="clr-code">RestService</code> from your browser application, you need to disable the currently
    loaded (local) <code class="clr-code">RestService</code> and switch over to the Java (remote) one. This can be done easily with a couple of commands.
</p>

<pre class="code"><code class="language-typescript" ngNonBindable>// to use remote RestService (remote, no security restrictions)
disableLocalRestService(): void &#123;

    ServiceLoader.offlineLocalRestService(); // offline the local (JavaScript) version of the RestService
    this.fabric.useFabricRestService(); // mark the RestService channel as galactic and fire off the request over the wire.
&#125;

// to use the local RestService (in browser - all restrictions apply)
enableLocalRestService(): void &#123;

    ServiceLoader.onlineLocalRestService(); // local RestService comes back online.
    this.fabric.useLocalRestService(); // no more Rest requests will be set over the wire.
&#125;
</code></pre>

<appfab-tryitout-component>
    <fabric-restservice-component></fabric-restservice-component>
</appfab-tryitout-component>

<p>The code we used to make the remote call above, is pretty simple. If you check your developer tools, you will see <strong class="emphasis">No XHR or Fetch calls</strong>
 being made by your browser. Everything is via the bus, over the websocket.</p>

<h3>Making an unrestricted API call using the Java fabric</h3>
<pre class="code"><code class="language-typescript" ngNonBindable>public requestAPI(): void &#123;
    this.iconState = ClrLoadingState.LOADING;

    // disable local Rest Service
    this.disableLocalRestService();
    this.response = "requesting from API, via Fabric (not local)....";

    this.restServiceRequest(
            &#123;
                uri: `https://jsonplaceholder.typicode.com/todos/$&#123;Math.floor(Math.random() * (10 - 1 + 1)) + 1&#125;`,
                method: HttpRequest.Get,
                successHandler: (response: any) => &#123;
                    this.iconState = ClrLoadingState.SUCCESS;
                    this.response = `API Call Success: $&#123;response.title&#125;`;
                    this.enableLocalRestService();
                &#125;,
                errorHandler: (error: RestError) => &#123;
                    this.iconState = ClrLoadingState.SUCCESS;
                    this.response = `API Response Error: $&#123;error.message&#125;`;
                    this.enableLocalRestService();
                &#125;
            &#125;
        );
&#125;
</code></pre>
<hr/>
<h3>Creating a Service to handle/hide API call logic.</h3>
<p>
    Let's create a simple service called <code class="clr-code">MyAPIService</code> that calls a remote API via the
    <code class="clr-code">RestService</code>
</p>

<p>This design would prevent any of your components containing any API or business logic for API calls (which is the way it should be)</p>

<h3>MyAPIService</h3>
<pre class="code"><code class="language-typescript" ngNonBindable>import &#123; AbstractService &#125; from '@vmw/bifrost/core';
import &#123; MessageArgs &#125; from '@vmw/bifrost';
import &#123; MyAPIServiceChannel, MyAPIServiceRequest, MyAPIServiceResponse &#125; from './myapi.service.model';
import &#123; HttpRequest, RestError &#125; from '@vmw/bifrost/core/services/rest/rest.model';
import &#123; ChannelName &#125; from '@vmw/bifrost';

export const MyAPIServiceChannel: ChannelName = 'services::MyAPIService';

export interface MyAPIServiceRequest &#123;
    id: number;
&#125;

export interface MyAPIServiceResponse &#123;
    message: string;
&#125;

export class MyAPIService extends AbstractService&lt;MyAPIServiceRequest, MyAPIServiceResponse&gt; &#123;

    constructor() &#123;

        // identify the name of this service, and the channel it operates on.
        super('MyAPIService', MyAPIServiceChannel);

        // log that the service is online (if logging enabled)
        this.log.info('MyAPIService Loaded');
    &#125;

    /**
     * Handle a request send on the service channel.
     * @param request the request object
     * @param args automatically passed by superclass, important details within, must include!
     */
    protected handleServiceRequest(request: MyAPIServiceRequest , args?: MessageArgs): void &#123;

        // call an API out there on the internets.
        this.restServiceRequest(
            &#123;
                uri: `https://jsonplaceholder.typicode.com/todos/$&#123;request.id&#125;`,
                method: HttpRequest.Get,
                successHandler: (response: any) =&gt; &#123;
                    this.postResponse(MyAPIServiceChannel, &#123; message: response.title &#125;, args);
                &#125;,
                errorHandler: (error: RestError) =&gt; &#123;
                    this.postError(MyAPIServiceChannel, error, args);
                &#125;
            &#125;,
            this.getName()
        );
    &#125;
&#125;
</code>
</pre>

<p>
    <code class="clr-code">MyAPIService</code> makes a very simple API request to a simple public API (no CORS
    restrictions). If there is a successful response (200), then the
    <code class="clr-code">successHandler()</code> is called and the service posts a response to the requester.
</p>
<p>
    To call <code class="clr-code">MyAPIService</code>, let's create a new component called <code class="clr-code">MyAPIComponent</code>
    that will call our new service.
</p>

<h3>MyAPIComponent</h3>
<pre class="code"><code class="language-typescript" ngNonBindable>import &#123; AbstractBase &#125; from '@vmw/bifrost/core';
import &#123; Component &#125; from '@angular/core';
import &#123; MyAPIServiceChannel, MyAPIServiceRequest, MyAPIServiceResponse &#125; from './myapi.service.model';
import &#123; ClrLoadingState &#125; from '@clr/angular';

@Component(&#123;
    selector: 'myapi-component',
    template: `
        &lt;button (click)="requestAPI()"  [clrLoading]="iconState"&gt;Request API&lt;/button&gt;&lt;br/&gt;
        Response: &#123;&#123;response&#125;&#125;`
&#125;)
export class MyAPIComponent extends AbstractBase &#123;

    public response = 'nothing yet, request something!';
    public iconState: ClrLoadingState = ClrLoadingState.DEFAULT;

    constructor() &#123;
        super('MyAPIComponent');
    &#125;

    /**
     * Send a request to MyAPI Service
     */
    public requestAPI(): void &#123;
        this.iconState = ClrLoadingState.LOADING;

        // generate an ID between 1 and 10.
        const request: MyAPIServiceRequest = &#123;
            id:  Math.floor(Math.random() * (10 - 1 + 1)) + 1
        &#125;;

        this.bus.requestOnce(MyAPIServiceChannel, request)
            .handle(
                (response: MyAPIServiceResponse) =&gt; &#123;
                    this.response = response.message;
                    this.iconState = ClrLoadingState.DEFAULT;
                &#125;
            );
    &#125;
&#125;</code></pre>

<p>
    You can try it out below!
</p>
<appfab-tryitout-component>
    <myapi-component></myapi-component>
</appfab-tryitout-component>
