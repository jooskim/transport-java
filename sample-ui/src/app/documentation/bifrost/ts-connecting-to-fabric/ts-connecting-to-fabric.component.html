
<h1>
    Connecting to the Fabric.
</h1>

<h3>Understanding the concept of the fabric.</h3>
<p>
    The key objective of the Fabric, is to provide a consistent, universal, decoupled and scalable foundation, on which to build fantastic user experiences that roam horizontally across our products and services.
</p>
<p>
    The fabric solves this problem by removing the need to manage, build and maintain API logic across services. This allows developers to focus on building experiences in individual UIs and CLIs, against a common
    and auto-generated fabric, instead of figuring out how to wire up an experience to an API and manage that constant change and integration with other services.
</p>
<p>
    The event bus provides the decoupling between consumers and producers. It provides a universal API that makes pub-sub simple across any set of distributed applications. This also allows us to locate producers
    and consumers where-ever we want inside the fabric.
</p>
<p>
    All those services we built for calling API's and handling business logic can be auto-generated by the SewingMachine. Because they can be autogenerated in TypeScript, Java and Go - we can build those services in Java or Go
    and run them in a micro-service that is also connected to the fabric.
</p>
<p>
    When you connect your application to the fabric, you will be extending your local event bus, to a distributed event bus via a message/event broker. This distributed event bus has many sources, relays, producers, consumers and integrations.
</p>
<p>
    As a developer, you would simply mark which channels you'd like to make 'Galactic' and they would be automatically bridged from your local application bus to the broker.
</p>
<p>
    The bus is designed to be extended, to child applications running in iframes, web components, shadow DOM - and to backend systems. This is key to making the distributed pattern work. The concept being that
    services can run in any platform, running any technology - but can communicate with one another. The transport becomes irrelevant, every actor in the system becomes either a producer
    or a consumer, as peers.
</p>

<hr/>
<h3>How the browser connects to the fabric.</h3>
<p>
    The browser connects to the Fabric via a WebSocket. The wire protocol used on the WebSocket is <a href="http://stomp.github.io/" target="_blank">STOMP</a>. STOMP stands for
    <span class="emphasis">Simple Text Oriented Messaging Protocol.</span>
</p>

<hr/>
<h4>Why STOMP?</h4>
<ol class="list">
    <li>
        It's a pub/sub protocol that is a standard and is <a href="http://stomp.github.io/implementations.html" target="_blank">widely accepted</a>. It means the fabric is compatible with any STOMP broker.
    </li>
    <li>
        You cannot talk AMQP over a WebSocket, Which means without STOMP, we can't talk directly to ANY broker.
    </li>
</ol>
<hr/>

<h3>
    What happens when I connect to the fabric?
</h3>

<p>
    Any channel that your application has been designated as 'galactic' will be automatically extended to the broker. It does this by mapping the channel name on your local bus, to a topic on the broker. If you open your developer
    tools, look
</p>
<p>
    If you don't know what a topic is, or you would like to know more about this stuff, <a href="https://www.oreilly.com/library/view/understanding-message-brokers/9781492049296/" target="_blank">here is a great introduction.</a>
</p>
<hr/>

<h3>Galactic Channels</h3>

<p>
    Galactic Channels are the same as regular channels, except they are distributed to the fabric. The idea here is that we don't want every channel on the bus distributed. When you create a galactic channel, you are
    bridging that specific channel from the browser, to the fabric. In pub-sub. this is the concept of subscribing to a destination topic or queue.
</p>
<p>
    You can create Galactic Channels at any time, once the Broker Connector is connected to a broker, those Galactic channels will be distributed.
</p>

<h4>How do I connect my bus to the fabric?</h4>

<p>
    We've tried to keep this as simple as possible. You should really just need to provide a connected and disconnected event handler.
</p>

<pre class="code"><code class="language-typescript" ngNonBindable>// Called when connected to fabric
const connectedHandler = (sessionId: string) => &#123;
    this.bus.logger.info(`Connected to Application Fabric with sessionId $&#123;sessionId&#125;`, 'main.ts');
&#125;;

// Called when disconnected.
const disconnectedHandler = () => &#123;
    this.bus.logger.info('Disconnected from Application Fabric.', 'main.ts');
&#123;

// Connect to Application Fabric.
thi.fabric.connect(connectedHandler, disconnectedHandler);</code></pre>

<p>
    If you need to configure the endpoint, host, port etc, you can also pass those in also as optional args.
</p>

<p>
    You can actually connect to <strong class="emphasis">appfabric.vmware.com</strong> and interact with the fabric for testing purposes.
</p>

<hr/>

<h4>Connecting to appfabric.vmware.com as an test endpoint</h4>
<pre class="code"><code class="language-typescript" ngNonBindable>// Connect to Application Fabric (on appfabric.vmware.com)
this.fabric.connect(
    connectedHandler,
    disconnectedHandler
    'appfabric.vmware.com'
);</code></pre>

<appfab-tryitout-component>
    <fabric-connect-sample></fabric-connect-sample>
</appfab-tryitout-component>

<p>
    Disconnecting is easy, you'll go offline instantly.
</p>

<h4>Disconnecting from fabric</h4>
<pre class="code"><code class="language-typescript" ngNonBindable>// Disconnect (close socket completely).
this.fabric.disconnect();</code></pre>

<hr/>

<h3>How does my application monitor the fabric connection state?</h3>

<p>
    How do I know if my application gets knocked offline? What is there is a hiccup on the WebSocket? The <code class="clr-code">this.fabric.whenConnectionStateChanges()</code>
    returns a <code class="clr-code">StoreStream&lt;FabricConnectionState&gt;</code> instance, that will stream connection state changes to the consumer.
</p>
<p>
    There are three different state changes emitted from this stream.
</p>
<ol class="list">
    <li><code class="clr-code">FabricConnectionState.Connected</code> - <span class="emphasis">Fabric connected!</span></li>
    <li><code class="clr-code">FabricConnectionState.Disconnected</code> - <span class="emphasis">Fabric disconnected!</span></li>
    <li><code class="clr-code">FabricConnectionState.Failed</code> - <span class="emphasis">Fabric unable to connect!</span></li>
</ol>

<h4>Using whenConnectionStateChanges()</h4>
<pre class="code"><code class="language-typescript" ngNonBindable>import &#123; FabricConnectionState &#125; from '@vmw/bifrost/fabric.api';

this.fabric.whenConnectionStateChanges()
    .subscribe(
        (stateChange: FabricConnectionState) => &#123;
            switch (stateChange) &#123;
                case FabricConnectionState.Connected:
                    // .. do something, now we're online.
                    break;

                case FabricConnectionState.Disconnected:
                    // .. do something, now we're offline.
                    break;

                case FabricConnectionState.Failed:
                    // .. do something important, we can't connect!
                    break;
                &#125;
            &#125;
     );
</code></pre>


