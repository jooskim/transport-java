<appfab-typescript-badges></appfab-typescript-badges>
<h1>Talking to peers across the fabric.</h1>

<p>
    The concept is that you send and receive messages to remote services or local services. In fact there is no difference in the API used. The only difference is that
    a channel marked as <span class="emphasis">Galactic</span> is going to become a distributed channel that is operating across the fabric, and not just locally in your application.
</p>
<p>
    Once your application is connected to the fabric, your requests and responses should behave as normal.
</p>
<h3>Joke-o-matic</h3>
<p>
    Ask the fabric for a joke, see what comes back.
</p>
<appfab-tryitout-component>
    <galactic-request-sample></galactic-request-sample>
</appfab-tryitout-component>

<p>
    This demo requests a joke via the fabric. This service is not running locally, it's actually running as a Java micro-service on the fabric.
</p>
<p>
    The component does not care if the service is local, or remote however.
</p>

<pre class="code"><code class="language-typescript" ngNonBindable>import &#123; ChangeDetectorRef, Component, OnDestroy, OnInit &#125; from '@angular/core';
import &#123; AbstractBase &#125; from '@vmw/bifrost/core';
import &#123; APIRequest, APIResponse, BusStore, StoreStream &#125; from '@vmw/bifrost';
import &#123; GeneralUtil &#125; from '@vmw/bifrost/util/util';
import &#123; ClrLoadingState &#125; from '@clr/angular';
import &#123; FabricConnectionState &#125; from '@vmw/bifrost/fabric.api';

@Component(&#123;
    selector: 'joke-o-matic',
    template: `
        &lt;div class="clr-row"&gt;
            &lt;div class="clr-col-2"&gt;
                &lt;button [clrLoading]="requestLoading" class="btn btn-primary-outline btn-sm" (click)="makeRequest()"&gt;
                    Ask For A Joke
                &lt;/button&gt;
            &lt;/div&gt;
            &lt;div class="clr-col-10" *ngIf="joke"&gt;
                &lt;blockquote&gt;&#123;&#123;joke&#125;&#125;&lt;/blockquote&gt;
            &lt;/div&gt;
        &lt;/div&gt;`
&#125;)
export class GalacticRequestComponent extends AbstractBase implements OnInit, OnDestroy &#123;

    public joke: string;
    requestLoading: ClrLoadingState = ClrLoadingState.DEFAULT;

    constructor( &#123;
        super('GalacticRequestComponent');
    &#125;

    ngOnInit(): void &#123;
        // mark the channel as galactic, so requests will be sent over the fabric as well as locally.
        this.bus.markChannelAsGalactic('servbot');
    &#125;

    ngOnDestroy(): void &#123;
        // mark the channel as local, no more requests will be distributed across the fabric
        this.bus.markChannelAsLocal('servbot');
    &#125;

    makeRequest(): void &#123;

        // show state on the button
        this.requestLoading = ClrLoadingState.LOADING;

        // make galactic joke request!
        this.bus.requestOnce(
            'servbot',
            this.fabric.generateFabricRequest('Joke', null) // generates a ready to go fabric command with (empty) payload.
            ).handle(
                (response: string) =&gt; &#123;
                    this.joke = response;
                    this.requestLoading = ClrLoadingState.DEFAULT;
                &#125;
            );
        );
    &#125;
&#125;</code></pre>

<h3>
    What is happening in the sample?
</h3>

<p>
    If you look at the  <code class="clr-code">ngOnInit()</code> and  <code class="clr-code">ngOnDestroy()</code> (essentially your component constructors and deconstructors) you can see
    that we're marking the channel as galactic when the component is created and marking it local when it's destroyed,
</p>
<p>
    Essentially, marking a channel as galactic <strong class="emphasis">extends it to the fabric</strong>, marking it as local <strong class="emphasis">boxes it to the local application</strong> only.
</p>
<h4>
    What is <code class="clr-code">this.fabric.generateFabricRequest()</code>?
</h4>

<p>
    This method creates a fabric ready request, capable of being routed across to services that are listening on remote / galactic channels. You supply a command and an optional payload to send.
</p>
<p>
    This is essentially how the SewingMachine builds services in an autogenerated fashion. Service requests are encapsulated request/response objects.
</p>
<hr/>

<h4>
    Can I still send stuff over galactic channels without using  <code class="clr-code">this.fabric.generateFabricRequest()</code>?
</h4>
<p>
    Yes. You can send what ever you like. If you want to take advantage of the Application Fabric, SewingMachine and auto-generation magic however, you will need to use this method to wrap your command/payload.
</p>

<hr/>
<h4>
    ðŸ‘‰ Use requests that operate over ID's or Transactions instead of public requests/responses to avoid crosstalk. ðŸ‘ˆ
</h4>
<hr/>
